<!DOCTYPE html>
<html>
<head>
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?dd5caa4e0169ff7ed21c4cdc78710602"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    <title>面试题集锦（JS篇） | 白夜的博客 | 进击的前端 | 学习笔记以及开源分享 | 身体和灵魂总得有一样在路上前行。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="面试题">
    <meta name="description" content="作用域什么是变量作用域
一个变量的作用域是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在js代码中任何地方都是有定义的。在函数内声明的变量只在函数体内有定义，它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。

如何解决跨域问题?
 jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面

什么是闭包">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题集锦（JS篇）">
<meta property="og:url" content="http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/index.html">
<meta property="og:site_name" content="白夜的博客">
<meta property="og:description" content="作用域什么是变量作用域
一个变量的作用域是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在js代码中任何地方都是有定义的。在函数内声明的变量只在函数体内有定义，它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。

如何解决跨域问题?
 jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面

什么是闭包">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/3117374-851c2c19c5b5a022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-08-20T18:01:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试题集锦（JS篇）">
<meta name="twitter:description" content="作用域什么是变量作用域
一个变量的作用域是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，在js代码中任何地方都是有定义的。在函数内声明的变量只在函数体内有定义，它们是局部变量，作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。

如何解决跨域问题?
 jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面

什么是闭包">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/3117374-851c2c19c5b5a022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    
        <link rel="alternate" type="application/atom+xml" title="白夜的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/head.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">白夜</h5>
          <a href="mailto:417940197@qq.com" title="417940197@qq.com" class="mail">417940197@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/kpengWang" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.facebook.com/kpeng1011" target="_blank" >
                <i class="icon icon-lg icon-facebook"></i>
                Facebook
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">面试题集锦（JS篇）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">面试题集锦（JS篇）</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-02-28T14:57:42.000Z" itemprop="datePublished" class="page-time">
  2017-02-28
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#作用域"><span class="post-toc-number">1.</span> <span class="post-toc-text">作用域</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#DOM"><span class="post-toc-number">2.</span> <span class="post-toc-text">DOM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BOM"><span class="post-toc-number">3.</span> <span class="post-toc-text">BOM</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据类型"><span class="post-toc-number">4.</span> <span class="post-toc-text">数据类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事件"><span class="post-toc-number">5.</span> <span class="post-toc-text">事件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数"><span class="post-toc-number">6.</span> <span class="post-toc-text">函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原型及原型链"><span class="post-toc-number">7.</span> <span class="post-toc-text">原型及原型链</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承"><span class="post-toc-number">8.</span> <span class="post-toc-text">继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#排序"><span class="post-toc-number">9.</span> <span class="post-toc-text">排序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#算法"><span class="post-toc-number">10.</span> <span class="post-toc-text">算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#同步异步"><span class="post-toc-number">11.</span> <span class="post-toc-text">同步异步</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HTTP"><span class="post-toc-number">12.</span> <span class="post-toc-text">HTTP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Ajax"><span class="post-toc-number">13.</span> <span class="post-toc-text">Ajax</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jQuery"><span class="post-toc-number">14.</span> <span class="post-toc-text">jQuery</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#移动端"><span class="post-toc-number">15.</span> <span class="post-toc-text">移动端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#this"><span class="post-toc-number">16.</span> <span class="post-toc-text">this</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#设计模式"><span class="post-toc-number">17.</span> <span class="post-toc-text">设计模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正则"><span class="post-toc-number">18.</span> <span class="post-toc-text">正则</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#优化"><span class="post-toc-number">19.</span> <span class="post-toc-text">优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实操代码实现"><span class="post-toc-number">20.</span> <span class="post-toc-text">实操代码实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#既定代码分析"><span class="post-toc-number">21.</span> <span class="post-toc-text">既定代码分析</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-面试题集锦（JS篇）"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">面试题集锦（JS篇）</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-02-28 22:57:42" datetime="2017-02-28T14:57:42.000Z"  itemprop="datePublished">2017-02-28</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>什么是变量作用域</strong></p>
<p>一个变量的作用域是程序源代码中定义这个变量的区域。全局变量拥有全局作用域，<br>在js代码中任何地方都是有定义的。在函数内声明的变量只在函数体内有定义，它们是局部变量，<br>作用域是局部性的。函数参数也是局部变量，它们只在函数体内有定义。</p>
<hr>
<p><strong>如何解决跨域问题?</strong></p>
<p> jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</p>
<hr>
<p><strong>什么是闭包（closure），为什么要用它？</strong><br>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p>
<hr>
<p><strong>什么是闭包? 堆栈溢出有什么区别？ 内存泄漏? 哪些操作会造成内存泄漏？怎么样防止内存泄漏？</strong></p>
<ul>
<li><strong>闭包</strong>：就是能够读取其他函数内部变量的函数。</li>
<li><strong>堆栈溢出</strong>：就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。经常会在递归中发生。</li>
<li><strong>内存泄露</strong>：用动态存储分配函数内存空间，在使用完毕后未释放，导致一直占据该内存单元。直到程序结束。指任何对象在您不再拥有或需要它之后仍然存在。</li>
<li><strong>造成内存泄漏</strong>：<br>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
<li><strong>防止内存泄露</strong>：<ol>
<li>不要动态绑定事件；</li>
<li>不要在动态添加，或者会被动态移除的dom上绑事件，用事件冒泡在父容器监听事件</li>
<li>如果要违反上面的原则，必须提供destroy方法，保证移除dom后事件也被移除，这点可以参考Backbone的源代码，做的比较好</li>
<li>单例化，少创建dom，少绑事件</li>
</ol>
</li>
</ul>
<hr>
<p><strong>闭包的特性</strong>：</p>
<ol>
<li>函数内再嵌套函数 </li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
<hr>
<p><strong>声明函数作用提升?声明变量和声明函数的提升有什么区别?</strong></p>
<ol>
<li><p>变量声明提升：变量申明在进入执行上下文就完成了。<br>只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；</p>
</li>
<li><p>函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数申明放在调用它的语句后面。<br>只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；</p>
</li>
<li><p>变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值。<br>同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a; </div><div class="line"><span class="keyword">var</span> c = <span class="number">1</span>; </div><div class="line">a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; </div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p><strong>节点类型?判断当前节点类型?</strong></p>
<ul>
<li>元素节点(1), </li>
<li>属性节点 (2)</li>
<li>文本节点 (3)</li>
<li>注释节点 (8)</li>
<li>文档节点 (9)</li>
</ul>
<p>通过nodeObject.nodeType判断节点类型：其中，nodeObject 为DOM节点（节点对象）。该属性返回以数字表示的节点类型，例如，元素节点返回 1，属性节点返回 2 。</p>
<hr>
<p><strong>如何添加一个dom对象到body中?innerHTML和innerText区别?</strong></p>
<p>body.appendChild(dom元素)；<br><code>innerHTML</code>:从对象的起始位置到终止位置的全部内容,包括Html标签。<br><code>innerText</code>:从起始位置到终止位置的内容, 但它去除Html标签 </p>
<hr>
<p><strong>如何copy一个dom元素？</strong></p>
<p>原生Js方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> clone = div.cloneNode();</div></pre></td></tr></table></figure>
<p>Jquery方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'div'</span>).clone();</div></pre></td></tr></table></figure>
<p>在默认情况下，.clone()方法不会复制匹配的元素或其后代元素中绑定的事件。不过，可以为这个方法传递一个布尔值参数，将这个参数设置为true, 就可以连同事件一起复制，即.clone(true)。</p>
<hr>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p><strong>分别简述五个window对象、属性</strong></p>
<p>成员对象 </p>
<ol>
<li>window.event </li>
<li>window.document </li>
<li>window.history </li>
<li>window.screen </li>
<li>window.navigator </li>
<li>window.external</li>
</ol>
<p>Window对象的属性</p>
<ol>
<li>window //窗户自身</li>
<li>window.self //引用本窗户window=window.self </li>
<li>window.name //为窗户命名 </li>
<li>window.defaultStatus //设定窗户状态栏信息 </li>
<li>window.location //URL地址,配备布置这个属性可以打开新的页面</li>
</ol>
<hr>
<p><strong>BOM 对象有哪些，列举 window 对象？</strong></p>
<ul>
<li>window 对象，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；</li>
<li>location 对象，浏览器当前URL信息；</li>
<li>navigator 对象，浏览器本身信息；</li>
<li>screen 对象，客户端屏幕信息；</li>
<li>history 对象，浏览器访问历史信息；</li>
</ul>
<hr>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>null，undefined 的区别？</strong></p>
<p>undefined表示变量声明但未初始化的值，null表示准备用来保存对象，还没有真正保存对象的值。    </p>
<ul>
<li><strong>null</strong>表示空值，转为数值时为0，从逻辑角度看，null表示一个空对象指针；</li>
<li><strong>undefined</strong>表示”缺少值”，就是此处应该有一个值，但是还没有定义。</li>
<li>变量被声明了，但没有赋值时，就等于undefined。</li>
<li>对象没有赋值的属性，该属性的值为undefined。</li>
<li>函数没有返回值时，默认返回undefined。</li>
</ul>
<hr>
<p><strong>new 操作符具体干了什么呢?</strong></p>
<ol>
<li>创建一个新对象；</li>
<li>把函数中上下文（作用域）对象this指向该对象；</li>
<li>执行代码，通过this给新对象添加属性或方法；</li>
<li>返回对象；</li>
</ol>
<hr>
<p><strong>“==” 和 “===” 有什么不同?</strong></p>
<ol>
<li><p>相同的是：== 和 === 都是比较等值比较运算符，返回的布尔类型的比较结果。</p>
</li>
<li><p>不同的是：</p>
<ul>
<li>== 是等值比较运算符，使用的是 抽象等值 比较算法。<br> === 是严格等值比较运算符，使用的 严格等值 比较算法。</li>
<li>== 运算符在比较值的时候，会根据两者类型是否相同而做不同的处理，<br> 在两者不同类型的时候，会转换类型后进行比较：<br> 基本类型会转成数字，引用类型会转成对象原始值，然后再进行比较。<br> 而 === 首先也会判断类型是否一致，不同的是如果类型不一致则直接返回 false。</li>
</ul>
</li>
</ol>
<p>资料参考：</p>
<ul>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1" target="_blank" rel="external">等值比较运算符 ( == )</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" target="_blank" rel="external">抽象比较算法</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.4" target="_blank" rel="external">严格等值比较运算符 ( === )</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6" target="_blank" rel="external">严格比较算法</a></li>
</ul>
<hr>
<p><strong>判断数据类型?</strong></p>
<p>typeof返回的类型都是字符串形式，可以判断function的类型；在判断除Object类型的对象时比较方便。<br>判断已知对象类型的方法： instanceof，后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。</p>
<hr>
<p><strong>数据类型?复杂数据类型?值类型和引用数据类型?堆栈数据结构?</strong></p>
<ol>
<li>基本数据类型：Undefined、Null、Boolean、Number、String</li>
<li>值类型：数值、布尔值、null、undefined。</li>
<li>引用类型：对象、数组、函数。</li>
<li>堆栈数据结构：是一种支持后进先出(LIFO)的集合,即后被插入的数据,先被取出!</li>
<li>js数组中提供了以下几个方法可以让我们很方便实现堆栈：<br>shift:从数组中把第一个元素删除，并返回这个元素的值。<br>unshift: 在数组的开头添加一个或更多元素，并返回新的长度<br>push:在数组的中末尾添加元素，并返回新的长度<br>pop:从数组中把最后一个元素删除，并返回这个元素的值。</li>
</ol>
<hr>
<p><strong>eval是做什么的？</strong></p>
<ul>
<li><p>它的功能是把对应的字符串解析成JS代码并运行；</p>
</li>
<li><p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 </p>
</li>
<li><p>由JSON字符串转换为JSON对象的时候可以用eval</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj =<span class="built_in">eval</span>(<span class="string">'('</span>+ str +<span class="string">')'</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>typeof？typeof [ ]返回数据类型是？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断基本数据类型；var a=[];typeof a输出object；</span></div><div class="line"><span class="comment">//本来判断一个对象类型用typeof是最好的，不过对于Array类型是不适用的，</span></div><div class="line"><span class="comment">//可以使用 instanceof操作符：</span></div><div class="line"><span class="keyword">var</span> arrayStr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>);    </div><div class="line">alert(arrayStr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); </div><div class="line"><span class="comment">//当然以上在一个简单的页面布局里面是没有问题的，如果是复杂页面情况，</span></div><div class="line"><span class="comment">//入获取的是frame内部的Array对象，可以用这个函数判断：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;      </div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;       </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>强制转换?显式转换? 隐式转换?**</p>
<ul>
<li>强制类型转换：</li>
</ul>
<p>明确调用内置函数，强制把一种类型的值转换为另一种类型。强制类型转换主要有：Boolean、Number、String、parseInt、parseFloat</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>)                <span class="comment">// =&gt; false - 零</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> object())   <span class="comment">// =&gt; true - 对象</span></div><div class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)       <span class="comment">// =&gt;   NaN</span></div><div class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)              <span class="comment">// =&gt; 0</span></div><div class="line"><span class="built_in">String</span>(<span class="literal">null</span>)              <span class="comment">// =&gt; "null"</span></div><div class="line"><span class="built_in">parseInt</span>( )</div><div class="line"><span class="built_in">parseFloat</span>( )</div><div class="line"><span class="built_in">JSON</span>.parse( )</div><div class="line"><span class="built_in">JSON</span>.stringify ( )</div></pre></td></tr></table></figure>
<ul>
<li><strong>隐式类型转换</strong></li>
</ul>
<p>在使用算术运算符时，运算符两边的数据类型可以是任意的，比如，一个字符串可以和数字相加。之所以不同的数据类型之间可以做运算，是因为JavaScript引擎在运算之前会悄悄的把他们进行了隐式类型转换的</p>
<ul>
<li><strong>显式转换</strong></li>
</ul>
<p>如果程序要求一定要将某一类型的数据转换为另一种类型，则可以利用强制类型转换运算符进行转换，这种强制转换过程称为显示转换。<br>显示转换是你定义让这个值类型转换成你要用的值类型，是底到高的转换。</p>
<hr>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>事件冒泡机制？</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://upload-images.jianshu.io/upload_images/3117374-851c2c19c5b5a022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JS事件捕获与冒泡原型图" title="">
                </div>
                <div class="image-caption">JS事件捕获与冒泡原型图</div>
            </figure></p>
<p>当页面中某个元素的事件被触发以后，比如点击了页面中的某个按钮，<br>就触发了当前按钮的点击事件，但是 JavaScript 并不是简单就直接触发该元素的相应事件，<br>而是会首先从 DOM 树的最顶层（window）依次的去触发目标（被直接点击的）元素所有父级的同类事件，<br>直到触发到目标元素，然后又会再一次的从目标元素开始触发其所有父级的所有同类事件直到window， 也就是同类型事件的目标元素与 window 之间触发一个来回，window 到目标的触发阶段，我们称为捕获阶段，目标触发事件的时候我们称为目标阶段，而最后目标到 window 的触发阶段，我们称为冒泡阶段。这种机制我们称为<em>事件流（event flow）</em>，冒泡机制其实就是事件流机制中的冒泡阶段规则。</p>
<blockquote>
<p>出处：<a href="https://www.w3.org/TR/2016/WD-uievents-20160804/" target="_blank" rel="external">https://www.w3.org/TR/2016/WD-uievents-20160804/</a> 中的<br>3.1. Event dispatch and DOM event flow</p>
</blockquote>
<hr>
<p><strong>事件委托？有什么好处? </strong></p>
<ul>
<li>利用冒泡的原理，把事件加到父级上，触发执行效果</li>
<li>好处：新添加的元素还会有之前的事件；提高性能。</li>
</ul>
<hr>
<p><strong>DOM事件的绑定的几种方式?</strong></p>
<p>。。。。。。。。。。。。。。。。。。。。。。</p>
<hr>
<p><strong>JavaScript 的事件流模型都有什么？</strong><br>分析：</p>
<blockquote>
<p>事件流描述的是从页面中接收事件的顺序。 DOM 结构是树形结构，当页面中的某一个元素触发了某个一个事件，事件会从最顶层的 window 对象开始，向下传播到目标元素，途径的祖先节点都会触发对应的事件，如果当前节点的该事件绑定了事件处理函数的话，则会执行该函数当事件达到目标元素并执行绑定函数（如果有绑定的话）后，事件又会向上传播到 window 元素，途径的祖先节点都会触发对应的事件（如果绑定事件处理函数的话）</p>
</blockquote>
<p>事件流包含三个阶段：</p>
<ul>
<li>事件捕捉阶段：事件开始由顶层对象触发，然后逐级向下传播，直到目标的元素；</li>
<li>处于目标阶段：处在绑定事件的元素上；</li>
<li>事件冒泡阶段：事件由具体的元素先接收，然后逐级向上传播，直到不具体的元素；</li>
</ul>
<hr>
<p><strong>window.onload ==? DOMContentLoaded ?</strong></p>
<p>一般情况下，DOMContentLoaded事件要在window.onload之前执行，当DOM树构建完成的时候就会执行DOMContentLoaded事件，而window.onload是在页面载入完成的时候，才执行，这其中包括图片等元素。大多数时候我们只是想在DOM树构建完成后，绑定事件到元素，我们并不需要图片元素，加上有时候加载外域图片的速度非常缓慢。</p>
<hr>
<p><strong>DOM事件中target和currentTarget的区别？</strong></p>
<p>。。。。。。。。。。。。。。。。。。。。。。</p>
<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>什么是回调函数?</strong><br>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<hr>
<p><strong>什么是构造函数？与普通函数有什么区别?</strong><br>构造函数：是一种特殊的方法、主要用来创建对象时初始化对象，总与new运算符一起使用，创建对象的语句中构造函数的函数名必须与类名完全相同。</p>
<p>与普通函数相比只能由new关键字调用，构造函数是类的标示</p>
<hr>
<p><strong>什么是自执行函数?用于什么场景？好处?</strong></p>
<ul>
<li><strong>自执行函数</strong>:1、声明一个匿名函数2、马上调用这个匿名函数。</li>
<li><strong>作用</strong>：创建一个独立的作用域</li>
<li><strong>好处</strong>：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理</li>
<li><strong>场景</strong>：一般用于框架、插件等场景</li>
</ul>
<hr>
<p><strong>new操作符具体干了什么呢?</strong></p>
<ol>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 </li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ol>
<hr>
<p><strong>通过new创建一个对象的时候，函数内部有哪些改变?</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Person.prototype.friend = [];</div><div class="line">Person.prototype.name = <span class="string">''</span>;</div><div class="line"><span class="comment">// var a = new Person();</span></div><div class="line"><span class="comment">// a.friend[0] = 'Nicholas';</span></div><div class="line"><span class="comment">// a.name = 'Antares';</span></div><div class="line"><span class="comment">// var b = new Person();</span></div><div class="line"><span class="comment">// b.friend？</span></div><div class="line"><span class="comment">// b.name?</span></div></pre></td></tr></table></figure>
<ol>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 </li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ol>
<hr>
<p><strong>编写一个 getElementsByClassName 封装函数?</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>   </div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">id</span> = <span class="string">"sub"</span> <span class="attr">class</span>=<span class="string">"ss confirm btn"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span>   </div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span></div><div class="line"><span class="comment">//方法一         </span></div><div class="line">    <span class="keyword">var</span> Opt = <span class="built_in">document</span>.getElementById(<span class="string">'sub'</span>);</div><div class="line">    <span class="keyword">var</span> getClass = <span class="function"><span class="keyword">function</span>(<span class="params">className,tagName</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.getElementsByTagName)&#123;</div><div class="line">            <span class="keyword">var</span> Inp = <span class="built_in">document</span>.getElementsByTagName(tagName);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;Inp.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span>((<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(\\s|^)'</span> +className +<span class="string">'(\\s|$)'</span>)).test(Inp[i].className))&#123;</div><div class="line">                      <span class="keyword">return</span> Inp[i];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.getElementsByClassName)&#123;</div><div class="line">                <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByClassName(className);</div><div class="line">        &#125;</div><div class="line">    &#125;                 </div><div class="line"><span class="comment">//方法二</span></div><div class="line">    <span class="keyword">var</span> aa = getClass(<span class="string">"confirm"</span>, <span class="string">"input"</span>);</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getClass</span>(<span class="params">className, targetName</span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> ele = [];</div><div class="line">            <span class="keyword">var</span> all = <span class="built_in">document</span>.getElementsByTagName(targetName || <span class="string">"*"</span>);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;all.length; i++)&#123;</div><div class="line">                <span class="keyword">if</span>(all[i].className.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(\\s|^)'</span>+confirm+<span class="string">'(\\s|$)'</span>)))&#123;    </div><div class="line">                    ele[ele.length] = all[i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> ele;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//方法三</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getObjsByClass</span>(<span class="params">tagName, className</span>)</span>&#123;</div><div class="line">           <span class="keyword">if</span>(<span class="built_in">document</span>.getElementsByClassName)&#123;</div><div class="line">               alert(<span class="string">"document.getElementsByClassName"</span>);</div><div class="line">               <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByClassName(className);</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               <span class="keyword">var</span> el = [];</div><div class="line">               <span class="keyword">var</span> _el = <span class="built_in">document</span>.getElementsByTagName(tagName);</div><div class="line">               <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;_el.length; i++)&#123;</div><div class="line">                   <span class="keyword">if</span>(_el[i].className.indexOf(className) &gt; <span class="number">-1</span>)&#123;</div><div class="line">                       alert(_el[i]);</div><div class="line">                       el[_el.length] = _el[i];</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               alert(el);</div><div class="line">               <span class="keyword">return</span> el;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<h3 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h3><p><strong>JavaScript 原型，原型链 ? 有什么特点？</strong></p>
<p>在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性[[prototype]],我们通常称之为原型.原型的值可以是一个对象,也可以是null.如果它的值是一个对象,则这个对象也一定有自己的原型.这样就形成了一条线性的链,我们称之为原型链. </p>
<p>访问一个对象的原型可以使用ES5中的Object.getPrototypeOf方法,或者ES6中的<strong>proto</strong>属性. 原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的。    </p>
<ul>
<li><strong>JavaScript 原型</strong>： 每创建一个函数，函数上都有一个属性为 prototype，它的值是一个对象。 这个对象的作用在于当使用函数创建实例的时候，那么这些实例都会共享原型上的属性和方法。</li>
</ul>
<ul>
<li><strong>原型链</strong>： 在 JavaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接（proto）。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向）。这种一级一级的链结构就称为原型链（prototype chain）。 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止;到查找到达原型链的顶部（Object.prototype），仍然没有找到指定的属性，就会返回 undefined。</li>
</ul>
<hr>
<p><strong>说一下原型链，对象，构造函数之间的一些联系?</strong></p>
<p>。。。。。。。。。。。。。。。。。。。。。。</p>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>Javascript如何实现继承？</strong></p>
<ol>
<li>构造继承</li>
<li>原型继承</li>
<li>实例继承</li>
<li>拷贝继承</li>
<li>使用对象冒充实现继承 </li>
<li>采用call、Apply方法改变函数上下文实现继承 </li>
<li>原型链方式继承</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123; </div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'wang'</span>; </div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123; </div><div class="line">  <span class="keyword">this</span>.age = <span class="number">28</span>; </div><div class="line">&#125; </div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型 </span></div><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child(); </div><div class="line">alert(demo.age); </div><div class="line">alert(demo.name);<span class="comment">//得到被继承的属性 &#125;</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>简述下 this 和定义属性和方法的时候有什么区别?Prototype？</strong></p>
<p>this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向。</p>
<p>prototype本质上还是一个JavaScript对象。 并且每个函数都有一个默认的prototype属性。</p>
<p>在prototype上定义的属性方法为所有实例共享，所有实例皆引用到同一个对象，单一实例对原型上的属性进行修改，也会影响到所有其他实例。</p>
<hr>
<p><strong>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</strong></p>
<p><code>hasOwnProperty</code></p>
<ul>
<li>hasOwnProperty函数方法是返回一个布尔值，</li>
<li>指出一个对象是否具有指定名称的属性。</li>
<li>此方法无法检查该对象的原型链中是否具有该属性；</li>
<li>该属性必须是对象本身的一个成员。<br>+如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</li>
</ul>
<hr>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><strong>实现对数组进行乱序</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</div><div class="line"><span class="keyword">var</span> sign = <span class="number">1</span>; </div><div class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<hr>
<p><strong> 数组的排序方法（sort）？排序？汉字排序？</strong></p>
<p>数组的排序方法：<code>reverse()</code>和<code>sort()</code>。<code>reverse()</code>方法会对反转数组项的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </div><div class="line">values.sort();<span class="comment">//0,1,10,15,5</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; </div><div class="line">values.reverse();<span class="comment">//5,4,3,2,1</span></div></pre></td></tr></table></figure>
<p>js中的排序（详情参考：<a href="http://link.zhihu.com/?target=http%3A//www.tuicool.com/articles/IjInMbU" target="_blank" rel="external">http://www.tuicool.com/articles/IjInMbU**</a>）<br>利用sort排序, 冒泡排序, 快速排序, 插入排序, 希尔排序, 选择排序<br>归并排序<br><code>localeCompare()</code>方法:用于字符串编码的排序<br><code>localeCompare</code>方法：返回一个值，指出在当前的区域设置中两个字符串是否相同。</p>
<hr>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>二分查找的时间复杂度怎么求，是多少？</strong></p>
<p>。。。。。</p>
<hr>
<p><strong>线性顺序存储结构和链式存储结构有什么区别？以及优缺点。</strong></p>
<p>。。。。。。</p>
<hr>
<h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><p> <strong>JavaScript提供了哪几种“异步模式</strong></p>
<ol>
<li>回调函数（callbacks）</li>
<li>事件监听</li>
<li>Promise对象</li>
</ol>
<hr>
<p><strong>同步和异步的区别?</strong></p>
<p>概念1：<strong>同步异步可以说是对被请求方来说的，被请求者使用什么方式来告知处理结果。</strong></p>
<ul>
<li>首先同步异步于阻塞非阻塞并没有关系。同步异步主要是事情做完以后，如何进行处理、或者说关注的是一 种消息通信机制。</li>
<li>同步的情况下，是由处理消息者自己去等待消息是否被触发；</li>
<li>异步的情况下是由触发机制来通知处理消息者；</li>
</ul>
<p>概念2：<strong>同步可以是阻塞的也可以是非阻塞的，异步也是如此。</strong></p>
<ul>
<li>阻塞非阻塞，主要是对于请求者而言的。</li>
<li>阻塞：发出请求等待结果返回，然后再处理后续的事情；</li>
<li>非阻塞：发出请求不等待结果返回，可以接着做后续的事情；</li>
</ul>
<ol>
<li>进程同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事</li>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</li>
</ol>
<hr>
<p><strong>异步编程？</strong></p>
<ol>
<li>方法1：回调函数，优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</li>
<li>方法2：时间监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</li>
<li>方法3：发布/订阅，性质与“事件监听”类似，但是明显优于后者。</li>
<li>方法4：Promises对象，是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。</li>
</ol>
<hr>
<p><strong>Promise?</strong></p>
<p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。</p>
<hr>
<p><strong>如何清除一个定时器?</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.clearInterval();</div><div class="line"><span class="built_in">window</span>.clearTimeout();</div></pre></td></tr></table></figure>
<hr>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>HTTP 状态消息 200 302 304 403 404 500 分别表示什么</strong></p>
<ul>
<li>100 <strong>Continue</strong> 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
<li>200：<strong>OK</strong> 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li>
<li>201：<strong>Created</strong> 请求成功并且服务器创建了新的资源</li>
<li>202：<strong>Accepted</strong> 服务器已接受请求，但尚未处理</li>
<li>301：<strong>Moved Permanently</strong> 请求的网页已永久移动到新位置。</li>
<li>302： <strong>Found</strong> 临时性重定向。请求的资源临时从不同的 URL 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。</li>
<li>303：<strong>See Other</strong> 临时性重定向，且总是使用 GET 请求新的 URL</li>
<li>304：<strong>Not Modified</strong> 自从上次请求后，请求的网页未修改过。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</li>
<li>400：<strong> Bad Request</strong> 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li>401：<strong> Unauthorized</strong> 请求未授权。</li>
<li>403：<strong>Forbidden</strong> 禁止访问。服务器已经理解请求，但是拒绝执行它。</li>
<li>404：<strong>Not Found</strong> 找不到如何与 URL 相匹配的资源。请求失败，请求所希望得到的资源未被在服务器上发现。</li>
<li>500：<strong>Internal Server Error</strong> 最常见的服务器端错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在<strong>服务器端的源代码出现错误时出现</strong>。</li>
<li>503 <strong>Service Unavailable</strong> 服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
<hr>
<p><strong>200和304的理解和区别?</strong></p>
<p>。。。。</p>
<hr>
<p><strong>有没有了解http2.0,websocket,https，说一下你的理解以及你所了解的特性？</strong></p>
<p>。。。。。</p>
<hr>
<p><strong>从服务器主动推送Data到客户端有那些方式？</strong></p>
<ul>
<li>html5提供的Websocket </li>
<li>不可见的iframe </li>
<li>WebSocket通过Flash </li>
<li>XHR长时间连接 </li>
<li>XHR Multipart Streaming </li>
<li>script标签的长时间连接(可跨域)</li>
</ul>
<hr>
<p><strong>readystate 0~4</strong></p>
<p>0：未初始化状态：此时，已经创建了一个XMLHttpRequest对象<br>1： 准备发送状态：此时，已经调用了XMLHttpRequest对象的open方法，并且XMLHttpRequest对象已经准备好将一个请求发送到服务器端<br>2：已经发送状态：此时，已经通过send方法把一个请求发送到服务器端，但是还没有收到一个响应<br>3：正在接收状态：此时，已经接收到HTTP响应头部信息，但是消息体部分还没有完全接收到<br>4：完成响应状态：此时，已经完成了HTTP响应的接收</p>
<hr>
<p><strong>xhr对象 status ? readystate?</strong></p>
<p>status是XMLHttpRequest对象的一个属性，表示响应的HTTP状态码。<br>readyState是XMLHttpRequest对象的一个属性，用来标识当前XMLHttpRequest对象处于什么状态。</p>
<hr>
<p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</strong></p>
<blockquote>
<p>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</p>
<p>简洁版(4次“握手”)： </p>
<ol>
<li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li>
<li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； </li>
<li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li>
<li>载入解析到的资源文件，渲染页面，完成。</li>
</ol>
<p>详细版：</p>
<ol>
<li>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; </li>
<li>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; </li>
<li>通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; </li>
<li>进行HTTP协议会话，客户端发送报头(请求报头); </li>
<li>进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; </li>
<li>进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; </li>
<li>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</li>
<li>浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</li>
<li>文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; </li>
<li>页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</li>
</ol>
</blockquote>
<hr>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p><strong>ajax 和 jsonp ？</strong></p>
<p>相同点：都是请求一个url<br>不同点：ajax的核心是通过xmlHttpRequest获取内容</p>
<p>ajax: 异步javascript和XML，是指一种创建交互式网页应用的网页开发技术。通过后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器 提供的js脚本。</p>
<hr>
<p><strong>GET和POST的区别，何时使用POST？</strong></p>
<ul>
<li>GET：一般用于查询数据，使用URL传递参数，由于浏览器对地址栏长度有限制，所以对使用get方式所发送信息的数量有限制，同时浏览器会记录（历史记录，缓存）中会保留请求地址的信息，包括地址后面的数据。get 只能发送普通格式（URL 编码格式）的数据。</li>
</ul>
<ul>
<li><p>POST：一般用于向服务器发送数据，对所发送的数据的大小理论上是没有限制，浏览器会缓存记录地址，但是不会记录 post 提交的数据。post 可以发送纯文本、URL编码格式、二进制格式的字符串，形式多样。</p>
</li>
<li><p>在以下情况中，请使用 POST 请求：</p>
<ol>
<li>以提交为目的的请求（类似语义化，get 表示请求，post 表示提交）；</li>
<li>发送私密类数据（用户名、密码）（因为浏览器缓存记录特性）；</li>
<li>向服务器发送大量数据（数据大小限制区别）；</li>
<li>上传文件图片时（数据类型区别）；</li>
</ol>
</li>
</ul>
<hr>
<p><strong>ajax请求方式有几种？</strong></p>
<ol>
<li>$.get(url,[data],[callback]) </li>
<li>$.getJSON(url,[data],[callback]) </li>
<li>$.post(url,[data],[callback],[type]) </li>
<li>$.ajax(opiton) </li>
<li>$.getScript( url, [callback] ) </li>
<li>jquery对象.load( url, [data], [callback] ) </li>
<li>serialize() 与 serializeArray()</li>
</ol>
<hr>
<p><strong>AJAX 的局限性?</strong></p>
<ul>
<li>不支持浏览器 back 按钮。</li>
<li>安全问题 AJAX 暴露了与服务器交互的细节。</li>
<li>对搜索引擎的支持比较弱。不会执行你的 JS 脚本，只会操作你的网页源代码；</li>
<li>跨域请求有一定限制。解决方式：jsonp；</li>
</ul>
<hr>
<p><strong>数据持久化技术(ajax)?简述ajax流程</strong></p>
<ol>
<li><p>客户端产生js的事件</p>
</li>
<li><p>创建XMLHttpRequest对象</p>
</li>
<li><p>对XMLHttpRequest进行配置</p>
</li>
<li><p>通过AJAX引擎发送异步请求</p>
</li>
<li><p>服务器端接收请求并且处理请求，返回html或者xml内容</p>
</li>
<li><p>XML调用一个callback()处理响应回来的内容</p>
</li>
<li><p>页面局部刷新</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">基本步骤：</div><div class="line"><span class="keyword">var</span> xhr =<span class="literal">null</span>;<span class="comment">//创建对象 </span></div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</div><div class="line">       xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">       xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">&#125;</div><div class="line">xhr.open(“方式”,”地址”,”标志位”);<span class="comment">//初始化请求 </span></div><div class="line">   xhr.setRequestHeader(“”,””);<span class="comment">//设置http头信息 </span></div><div class="line">xhr.onreadystatechange =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//指定回调函数 </span></div><div class="line">xhr.send();<span class="comment">//发送请求</span></div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>如何确保ajax或连接不走缓存路径</strong></p>
<p>在Ajax中使用Get请求数据不会有页面缓存的问题，而使用POST请求可是有时候页面会缓存我们提交的信息，导致我们发送的异步请求不能正确的返回我们想要的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.post(url,data ,<span class="attr">ranNum</span>:<span class="built_in">Math</span>.random()&#125; ,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;&#125;）</div></pre></td></tr></table></figure>
<p>ranNum : 这个是防止缓存的核心，每次发起请求都会用Math.random()方法生成一个随机的数字，这样子就会刷新url缓存</p>
<hr>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p><strong>请指出 JQuery中 “.bind()”、”.live()” 和 “delegate()” 的区别？</strong></p>
<p>参考答案：</p>
<ol>
<li>bind：把函数直接绑定到指定元素的指定事件上。</li>
<li>live：把函数绑定到document上，接收选择器和事件类型作为参数，当触发一个元素的事件的时候，会利用事件冒泡到document上这一特性，判断事件目标元素和绑定参数中的选择器是否匹配，如果匹配则执行绑定函数的执行。</li>
<li>delegate：和live有点类似，但是可以指定绑定元素，而不是document，其他和live一致，但是比live更加灵活。</li>
</ol>
<hr>
<p><strong>$(function(){})和window.onload 和 $(document).ready(function(){})</strong></p>
<ul>
<li><strong><code>window.onload</code>:</strong>用于当页面的所有元素，包括外部引用文件，图片等都加载完毕时运行函数内的函数。load方法只能执行一次，如果在js文件里写了多个，只能执行最后一个。</li>
<li><strong><code>$(document).ready(function(){})</code></strong>和<strong><code>$(function(){})</code></strong>都是用于当页面的标准DOM元素被解析成DOM树后就执行内部函数。这个函数是可以在js文件里多次编写的，对于多人共同编写的js就有很大的优势，因为所有行为函数都会执行到。而且$(document).ready()函数在HMTL结构加载完后就可以执行，不需要等大型文件加载或者不存在的连接等耗时工作完成才执行，效率高。</li>
</ul>
<hr>
<p><strong>attr 和 prop 有什么区别?</strong></p>
<ul>
<li>对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。</li>
<li>对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。</li>
</ul>
<hr>
<p><strong>$(“.foo div#bar:eq(0)”) 请优化这段 JQuery 选择器？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#bar:eq(0)"</span>)</div></pre></td></tr></table></figure>
<hr>
<p><strong>Jq中怎么样编写插件?</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种是类级别的插件开发：</span></div><div class="line"><span class="comment">//1.1 添加一个新的全局函数 添加一个全局函数，我们只需如下定义： </span></div><div class="line">jQuery.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     alert(<span class="string">'This is a test. This is only a test.'</span>);  &#125;;   </div><div class="line"></div><div class="line"><span class="comment">//1.2 增加多个全局函数 添加多个全局函数，可采用如下定义： </span></div><div class="line">jQuery.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       alert(<span class="string">'This is a test. This is only a test.'</span>);  &#125;;  </div><div class="line">jQuery.bar = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">      alert(<span class="string">'This function takes a parameter, which is "'</span> + param + <span class="string">'".'</span>);  &#125;;   调用时和一个函数的一样的:jQuery.foo();jQuery.bar();或者$.foo();$.bar(<span class="string">'bar'</span>);</div><div class="line"><span class="comment">//1.3 使用jQuery.extend(object);　 </span></div><div class="line">jQuery.extend(&#123;</div><div class="line">      <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          alert(<span class="string">'This is a test. This is only a test.'</span>);</div><div class="line">        &#125;,</div><div class="line">      <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">          alert(<span class="string">'This function takes a parameter, which is "'</span> + param +<span class="string">'".'</span>);</div><div class="line">        &#125;</div><div class="line">     &#125;); </div><div class="line"><span class="comment">//1.4 使用命名空间</span></div><div class="line"><span class="comment">// 虽然在jQuery命名空间中，我们禁止使用了大量的javaScript函数名和变量名。</span></div><div class="line"><span class="comment">// 但是仍然不可避免某些函数或变量名将于其他jQuery插件冲突，因此我们习惯将一些方法</span></div><div class="line"><span class="comment">// 封装到另一个自定义的命名空间。</span></div><div class="line">jQuery.myPlugin = &#123;         </div><div class="line"><span class="attr">foo</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;         </div><div class="line">  alert(<span class="string">'This is a test. This is only a test.'</span>);         </div><div class="line"> &#125;,         </div><div class="line"> <span class="attr">bar</span>:<span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;         </div><div class="line">  alert(<span class="string">'This function takes a parameter, which is "'</span> + param + <span class="string">'".'</span>);   </div><div class="line"> &#125;        </div><div class="line">&#125;; </div><div class="line"><span class="comment">//采用命名空间的函数仍然是全局函数，调用时采用的方法： </span></div><div class="line">$.myPlugin.foo();        </div><div class="line">$.myPlugin.bar(<span class="string">'baz'</span>);</div><div class="line"><span class="comment">//通过这个技巧（使用独立的插件名），我们可以避免命名空间内函数的冲突。</span></div><div class="line"></div><div class="line"><span class="comment">//第二种是对象级别的插件开发</span></div><div class="line"><span class="comment">//形式1： </span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;    </div><div class="line">  $.fn.extend(&#123;    </div><div class="line">   <span class="attr">pluginName</span>:<span class="function"><span class="keyword">function</span>(<span class="params">opt,callback</span>)</span>&#123;    </div><div class="line">             <span class="comment">// Our plugin implementation code goes here.      </span></div><div class="line">   &#125;    </div><div class="line">  &#125;)    </div><div class="line">&#125;)(jQuery);  </div><div class="line"></div><div class="line"><span class="comment">//形式2：</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;      </div><div class="line">   $.fn.pluginName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </div><div class="line">        <span class="comment">// Our plugin implementation code goes here.    </span></div><div class="line">   &#125;;     </div><div class="line">&#125;)(jQuery);</div><div class="line"><span class="comment">//形参是$，函数定义完成之后,把jQuery这个实参传递进去.立即调用执行。</span></div><div class="line"><span class="comment">//这样的好处是,我们在写jQuery插件时,也可以使用$这个别名,而不会与prototype引起冲突</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>Jq中如何实现多库并存?</strong></p>
<p><strong>方法一：</strong></p>
<p>利用jQuery的实用函数<code>$.noConflict()</code>;这个函数归还$的名称控制权给另一个库，因此可以在页面上使用其他库。这时，我们可以用”jQuery “这个名称调用jQuery的功能。</p>
<p>或者给jQuery一个别名 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $j=jQuery</div></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;&#125;)(jQuery)</div></pre></td></tr></table></figure>
<p>方法三：</p>
<p>通过传递一个函数作为jQuery的参数，因此把这个函数声明为就绪函数。 我们声明$为就绪函数的参数，因为jQuery总是吧jQuery对象的引用作为第一个参数传递，所以就保证了函数的执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure>
<hr>
<p><strong>Jq中有几种选择器?分别是什么?</strong></p>
<ol>
<li>层叠选择器、</li>
<li>基本过滤选择器、</li>
<li>内容过滤选择器、</li>
<li>可视化过滤选择器、</li>
<li>属性过滤选择器、</li>
<li>子元素过滤选择器、</li>
<li>表单元素选择器、</li>
<li>表单元素过滤选择器</li>
</ol>
<hr>
<p><strong>$(‘div+.ab’)和$(‘.ab+div’) 哪个效率高？</strong></p>
<p><code>$(&#39;div+.ab&#39;)</code>效率高</p>
<hr>
<p><strong>$.map和$.each有什么区别</strong></p>
<ul>
<li>map()方法主要用来遍历操作数组和对象，会返回一个新的数组。$.map()方法适用于将数组或对象每个项目新阵列映射到一个新数组的函数；</li>
<li>each()主要用于遍历jquery对象，返回的是原来的数组，并不会新创建一个数组。</li>
</ul>
<hr>
<p><strong>Jq中get()和eq()有什么区别？</strong></p>
<p><code>get()</code> :取得其中一个匹配的元素。num表示取得第几个匹配的元素，get多针对集合元素，返回的是DOM对象组成的数组 </p>
<p><code>eq()</code>:获取第N个元素，下标都是从0开始，返回的是一个JQuery对象</p>
<hr>
<p><strong>Jq中如何将一个jq对象转化为dom对象？</strong></p>
<p>方法一：</p>
<p>jQuery对象是一个数据对象，可以通过[index]的方法，来得到相应的DOM对象。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $v =$(<span class="string">"#v"</span>) ; <span class="comment">//jQuery对象 </span></div><div class="line"><span class="keyword">var</span> v=$v[<span class="number">0</span>]; <span class="comment">//DOM对象 </span></div><div class="line">alert(v.checked) <span class="comment">//检测这个checkbox是否被选中</span></div></pre></td></tr></table></figure>
<p><strong>方法二：</strong><br>jQuery本身提供，通过.get(index)方法，得到相应的DOM对象 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $v=$(<span class="string">"#v"</span>); <span class="comment">//jQuery对象 </span></div><div class="line"><span class="keyword">var</span> v=$v.get(<span class="number">0</span>); <span class="comment">//DOM对象 </span></div><div class="line">alert(v.checked) <span class="comment">//检测这个checkbox是否被选中</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>Jq绑定事件的几种方式？</strong></p>
<p>jQuery中提供了四种事件监听方式，分别是bind、live、delegate、on，对应的解除监听的函数分别是unbind、die、undelegate、off</p>
<ul>
<li><code>bind( )</code>是使用频率较高的一种，作用就是在选择到的元素上绑定特定事件类型的监听函数;</li>
<li><code>live( )</code>可以对后生成的元素也可以绑定相应的事件,处理机制就是把事件绑定在DOM树的根节点上，而不是直接绑定在某个元素上;</li>
<li><code>delegate()</code>采用了事件委托的概念，不是直接为子元素绑定事件，而是为其父元素（或祖先元素也可）绑定事件，当在div内任意元素上点击时，事件会一层层从event target向上冒泡，直至到达你为其绑定事件的元素；</li>
<li><code>on()</code>方法可以绑定动态添加到页面元素的事件，on()方法绑定事件可以提升效率；</li>
</ul>
<hr>
<p><strong>Jq如何判断元素显示隐藏？</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//第一种：使用CSS属性 </div><div class="line">var display =$('#id').css('display'); </div><div class="line">if(display == 'none')&#123;    alert("我是隐藏的！"); &#125;</div><div class="line">//第二种：使用jquery内置选择器 </div><div class="line">&lt;div id="test"&gt; &lt;p&gt;仅仅是测试所用&lt;/p&gt; &lt;/div&gt;</div><div class="line">if($("#test").is(":hidden"))&#123;        $("#test").show();    //如果元素为隐藏,则将它显现 &#125;else&#123;       $("#test").hide();     //如果元素为显现,则将其隐藏 &#125;</div><div class="line">//第三种：jQuery判断元素是否显示 是否隐藏</div><div class="line">var node=$('#id');</div><div class="line">if(node.is(':hidden'))&#123;　　//如果node是隐藏的则显示node元素，否则隐藏</div><div class="line">　　node.show();　</div><div class="line">&#125;else&#123;</div><div class="line">　　node.hide();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>jquery和zepto有什么区别?</strong></p>
<ol>
<li>针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。</li>
<li>Dom操作的区别：添加id时jQuery不会生效而Zepto会生效。</li>
<li>zepto主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。<br>jquery主要是兼容性好，可以跑在各种pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。</li>
</ol>
<hr>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><strong>移动端什么是移动端的300ms延迟？</strong></p>
<p>移动端300ms延迟：假定这么一个场景。用户在 浏览器里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，浏览器 就等待 300 毫秒，以判断用户是否再次点击了屏幕。也就是说，当我们点击页面的时候移动端浏览器并不是立即作出反应，而是会等上一小会儿才会出现点击的效果。</p>
<p>300ms延迟解决方案：</p>
<ol>
<li>禁用缩放，在html文档头部加meta标签如下：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”viewport”</span> <span class="attr">content</span>=<span class="string">”user-scalable</span>=<span class="string">no”/</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>更改默认的视口宽度 （响应式布局，消除了站点上可能存在的双击绽放的请求）</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”viewport”</span> <span class="attr">content</span>=<span class="string">”width</span>=<span class="string">device-width”/</span>&gt;</span></div></pre></td></tr></table></figure>
<ol>
<li>Css touch-action</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*在该元素上的操作不会触发用户代理的任何行为，无需进行3000ms延迟判断。*/</span></div><div class="line"><span class="selector-tag">touch-action</span><span class="selector-pseudo">:none</span>;</div></pre></td></tr></table></figure>
<ol>
<li>FastClick为解决移动端浏览器300毫秒延迟开发的一个轻量级的库</li>
</ol>
<hr>
<p><strong>移动端上什么是点击穿透?</strong></p>
<p>点击穿透现象有3种：<br><strong>点击穿透问题</strong>：点击蒙层（mask）上的关闭按钮，蒙层消失后发现触发了按钮下面元素的click<strong>事件跨页面点击穿透问题</strong>：如果按钮下面恰好是一个有href属性的a标签，那么页面就会发生跳转另<strong>一种跨页面点击穿透问题</strong>：这次没有mask了，直接点击页内按钮跳转至新页，然后发现新页面中对应位置元素的click事件被触发了</p>
<p>解决方案:</p>
<ol>
<li><p>只用touch</p>
<p>最简单的解决方案，完美解决点击穿透问题<br>把页面内所有click全部换成touch事件（ touchstart 、’touchend’、’tap’）</p>
</li>
<li><p>只用click</p>
<p>下下策，因为会带来300ms延迟，页面内任何一个自定义交互都将增加300毫秒延迟</p>
</li>
<li><p>tap后延迟350ms再隐藏mask</p>
</li>
</ol>
<p>​      改动最小，缺点是隐藏mask变慢了，350ms还是能感觉到慢的</p>
<ol>
<li><p>pointer-events</p>
<p>比较麻烦且有缺陷， 不建议使用mask隐藏后，给按钮下面元素添上 pointer-events: none; 样式，让click穿过去，350ms后去掉这个样式，恢复响应缺陷是mask消失后的的350ms内，用户可以看到按钮下面的元素点着没反应，如果用户手速很快的话一定会发现</p>
</li>
</ol>
<hr>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><strong>谈谈This对象的理解。</strong></p>
<ul>
<li>this总是指向函数的直接调用者（而非间接调用者）；</li>
<li>如果有new关键字，this指向new出来的那个对象；</li>
<li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</li>
</ul>
<hr>
<p><strong>ES6的箭头函数里的this?</strong></p>
<p>。。。。</p>
<hr>
<p><strong>解释 call 与 apply 的区别：</strong></p>
<ul>
<li>call 和 apply 都是函数下的一个静态方法，可以通过函数 .call() 或 函数 .apply() 的方式来间接调用该函数，通过 call 或 apply 执行时候的第一个参数改变该函数执行过程中的上下文对象（this），如果第一个参数不存在或者设置成 null/undefined，那么该函数执行过程中的上下文对象指向全局上下文对象，在 JavaScript 中指向了 window 对象。</li>
<li>不同之处在于后续参数上，call 第一个参数以后的参数值将被一一对应的赋值给源函数的形参，而 apply 则是传入一个数组，间接传给函数的 arguments 对象。</li>
</ul>
<hr>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><strong>程序的设计模式?工厂模式?发布订阅?</strong></p>
<ol>
<li>设计模式并不是某种语言的某块代码，设计模式是一种思想，提供给在编码时候遇到的各种问题是可以采取的解决方案，更倾向于一种逻辑思维，而不是万能代码块。</li>
</ol>
<p>设计模式主要分三个类型:创建型、结构型和行为型。</p>
<ul>
<li>创建型模式：单例模式，抽象工厂模式，建造者模式，工厂模式与原型模式。</li>
<li>结构型模式：适配器模式，桥接模式，装饰者模式，组合模式，外观模式，享元模式以及代理模式。</li>
<li>行为型模式：模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式和访问者模式。</li>
</ul>
<ol>
<li>与创建型模式类似，工厂模式创建对象（视为工厂里的产品）是无需指定创建对象的具体类。<br>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</li>
<li>观察者模式又叫做发布订阅模式，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察着对象。它是由两类对象组成，主题和观察者，主题负责发布事件，同时观察者通过订阅这些事件来观察该主体，发布者和订阅者是完全解耦的，彼此不知道对方的存在，两者仅仅共享一个自定义事件的名称。</li>
</ol>
<hr>
<p><strong>javascript创建对象的几种方式？</strong><br>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</p>
<ol>
<li><p><strong>对象字面量的方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person=&#123;<span class="attr">firstname</span>:<span class="string">"Mark"</span>,<span class="attr">lastname</span>:<span class="string">"Yun"</span>,<span class="attr">age</span>:<span class="number">25</span>,<span class="attr">eyecolor</span>:<span class="string">"black"</span>&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>用function来模拟无参的构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(); <span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class person.name="Mark";</span></div><div class="line">person.age = <span class="string">"25"</span>;</div><div class="line">person.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    alert(person.name + <span class="string">" hello..."</span>);</div><div class="line">&#125;</div><div class="line">person.work();</div></pre></td></tr></table></figure>
</li>
<li><p><strong>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）  </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pet</span>(<span class="params">name, age, hobby</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name; <span class="comment">//this作用域：当前对象</span></div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.hobby = hobby;</div><div class="line">  <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="string">"我叫"</span> + <span class="keyword">this</span>.name + <span class="string">",我喜欢"</span> + <span class="keyword">this</span>.hobby + <span class="string">",是个程序员"</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> maidou = <span class="keyword">new</span> Pet(<span class="string">"麦兜"</span>, <span class="number">25</span>, <span class="string">"coding"</span>); <span class="comment">//实例化、创建对象 maidou.eat();//调用eat方法</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong> 用工厂方式来创建（内置对象） </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wcDog =<span class="keyword">new</span> <span class="built_in">Object</span>(); </div><div class="line">wcDog.name=<span class="string">"旺财"</span>; </div><div class="line">wcDog.age=<span class="number">3</span>; </div><div class="line">wcDog.work=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"我是"</span>+wcDog.name+<span class="string">",汪汪汪......"</span>);</div><div class="line"> &#125; </div><div class="line">wcDog.work();</div></pre></td></tr></table></figure>
</li>
<li><p><strong>用原型方式来创建 </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123; &#125; </div><div class="line">Dog.prototype.name=<span class="string">"旺财"</span>;</div><div class="line">Dog.prototype.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   alert(<span class="keyword">this</span>.name+<span class="string">"是个吃货"</span>);</div><div class="line"> &#125; </div><div class="line"><span class="keyword">var</span> wangcai =<span class="keyword">new</span> Dog(); </div><div class="line">wangcai.eat();</div></pre></td></tr></table></figure>
</li>
<li><p><strong>用混合方式来创建 </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">name,price</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name=name;</div><div class="line">  <span class="keyword">this</span>.price=price;</div><div class="line"> &#125; </div><div class="line">Car.prototype.sell=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     alert(<span class="string">"我是"</span>+<span class="keyword">this</span>.name+<span class="string">"，我现在卖"</span>+<span class="keyword">this</span>.price+<span class="string">"万元"</span>);</div><div class="line"> &#125; </div><div class="line"><span class="keyword">var</span> camry =<span class="keyword">new</span> Car(<span class="string">"凯美瑞"</span>,<span class="number">27</span>); </div><div class="line">camry.sell();</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p><strong>以字母开头，可以包含字母、数字、下划线的正则表达式？</strong></p>
<p><code>/^[a-zA-Z]\w+$/</code></p>
<hr>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p><strong>js延迟加载的方式有哪些？</strong></p>
<p>normaldefer和async、动态创建DOM方式（用得最多）、按需异步载入js</p>
<hr>
<p><strong>请列举一些浏览器兼容性问题？以及提高性能方面的方案</strong></p>
<p><strong>JS兼容问题</strong></p>
<ol>
<li><p>JSON 解析问题：<br>ecmascript5 通过 JSON 对象进行处理，ecmascript5 之前通过 eval 进行解析；</p>
</li>
<li><p>自定义属性问题：</p>
<ul>
<li>IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；</li>
<li>Firefox下，只能使用 getAttribute( )获取自定义属性。</li>
</ul>
<p>解决办法：统一通过 getAttribute() 获取自定义属性，不过更推荐直接通过 “点” 运算符访问元素属性。</p>
</li>
<li><p>事件对象兼容性问题：<br>非标准 IE 和 chrome 下可以通过全局 event 对象来获取，标准（包括标准 IE，chrome 等）浏览器通过事件函数的第一个参数传入。</p>
</li>
<li><p>事件源对象<br>IE 下使用 event.srcElement，标准下使用 event.target 来获取。</p>
</li>
<li><p>阻止事件冒泡<br>通常可以通过 event.cancelBubble = false 来阻止，但是标准推荐使用 event.stopPropagation() 方法来阻止；</p>
</li>
<li><p>事件默认行为的阻止<br>DOM1 事件绑定中(属性 on… 的方式)可以通过 return false 来阻止，但是在 DOM2 的事件绑定中(addEventListener)中，只能通过 event.preventDefault() 方法来阻止。</p>
</li>
</ol>
<p><strong>JS 优化问题 </strong></p>
<ol>
<li>最小化 DOM 访问次数，尽可能在 JS 端执行；</li>
<li>如果需要多次访问某个 DOM 节点，请使用局部变量存储对它的引用；</li>
<li>小心处理 HTML 集合，因为它实时连系着底层的文档，把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中；</li>
<li>如果可能的话，使用速度更快的 API，比如 querySelectorAll 和 firstElementChild；</li>
<li>要留意重绘和重排，批量修改样式时，“离线”操作 DOM 树。使用缓存，并减少访问布局的次数；</li>
<li>使用事件委托来减少事件处理器的数量；</li>
<li>避免多次访问对象成员或函数中的全局变量，尽量将它们赋值给局部变量以缓存；</li>
<li>能用 CSS 解决的问题，尽量不用 JS 去解决；</li>
</ol>
<hr>
<h3 id="实操代码实现"><a href="#实操代码实现" class="headerlink" title="实操代码实现"></a>实操代码实现</h3><p><strong>如何通过原生js 判断一个元素当前是显示还是隐藏状态?</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).css(<span class="string">"display"</span>)===<span class="string">'none'</span>)</div><div class="line"><span class="keyword">if</span>( <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).css(<span class="string">"display"</span>)===<span class="string">'block'</span>)</div><div class="line">$(<span class="string">"#div"</span>).is(<span class="string">":hidden"</span>); <span class="comment">// 判断是否隐藏</span></div><div class="line">$(<span class="string">"#div"</span>).is(<span class="string">":visible"</span>) <span class="comment">// 判断是否显示</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>如何合并两个数组？数组删除一个元素?</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法一</span></div><div class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">arr1 = arr1.concat(arr2);</div><div class="line"><span class="built_in">console</span>.log(arr1); </div><div class="line"></div><div class="line"><span class="comment">//方法二</span></div><div class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1,arr2);</div><div class="line"><span class="built_in">console</span>.log(arr1);</div><div class="line"></div><div class="line"><span class="comment">//方法三</span></div><div class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; arr2.length; i++) &#123;</div><div class="line">arr1.push( arr2[i] );</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(arr1);</div></pre></td></tr></table></figure>
<hr>
<p><strong>写一个通用的事件侦听器函数？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">markyun.Event = &#123; <span class="comment">// 页面加载完成后 </span></div><div class="line">    readyEvent: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fn == <span class="literal">null</span>) &#123;</div><div class="line">            fn = <span class="built_in">document</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> oldonload = <span class="built_in">window</span>.onload;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.onload != <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="built_in">window</span>.onload = fn;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                oldonload();</div><div class="line">                fn();</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件 </span></div><div class="line">    <span class="comment">// 参数： 操作的元素,事件名称 ,事件处理程序 </span></div><div class="line">    addEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">            <span class="comment">//事件类型、需要执行的函数、是否捕捉 </span></div><div class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">            element.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                handler.call(element);</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 移除事件 </span></div><div class="line">    removeEvent: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.datachEvent) &#123;</div><div class="line">            element.detachEvent(<span class="string">'on'</span> + type, handler);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) </span></div><div class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ev.stopPropagation) &#123;</div><div class="line">            ev.stopPropagation();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ev.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 取消事件的默认行为 </span></div><div class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 获取事件目标 </span></div><div class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 获取event对象的引用，取到事件的所有信息，确保随时能使用event； </span></div><div class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> ev = e || <span class="built_in">window</span>.event;</div><div class="line">        <span class="keyword">if</span> (!ev) &#123;</div><div class="line">            <span class="keyword">var</span> c = <span class="keyword">this</span>.getEvent.caller;</div><div class="line">            <span class="keyword">while</span> (c) &#123;</div><div class="line">                ev = c.arguments[<span class="number">0</span>];</div><div class="line">                <span class="keyword">if</span> (ev &amp;&amp; Event == ev.constructor) &#123; <span class="keyword">break</span>; &#125;</div><div class="line">                c = c.caller;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ev;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<p><strong>实现一个函数 clone()，可以对 JavaScript 中的5种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制。</strong></p>
<p>这道题考察了以下知识点：</p>
<ul>
<li>使用 typeof 判断值得类型；</li>
<li>使用 toString 区分数组和对象；</li>
<li>递归函数的使用；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="comment">//判断是对象，就进行循环复制</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">'null'</span>) &#123;</div><div class="line">        <span class="comment">// 区分是数组还是对象，创建空的数组或对象</span></div><div class="line">        <span class="keyword">var</span> o = <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">"Array"</span> ? [] : &#123;&#125;;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</div><div class="line">            <span class="comment">// 如果属性对应的值为对象，则递归复制</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[k] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj[k] !== <span class="string">'null'</span>)&#123;</div><div class="line">                o[k] = clone(obj[k])</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                o[k] = obj[k];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//不为对象，直接把值返回</span></div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="既定代码分析"><a href="#既定代码分析" class="headerlink" title="既定代码分析"></a>既定代码分析</h3><p><strong>判断代码输出结果</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"test is a Number--"</span> + (test.constructor == <span class="built_in">Number</span>));  <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> t1 = <span class="keyword">new</span> test1();</div><div class="line"></div><div class="line"><span class="keyword">var</span> test2 = <span class="string">"37degree"</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.info(<span class="string">"typeof test--"</span> + <span class="keyword">typeof</span> test); <span class="comment">//number</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.info(<span class="string">"typeof test1--"</span> + <span class="keyword">typeof</span> test1);  <span class="comment">//function</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.info(<span class="string">"typeof t1--"</span> + <span class="keyword">typeof</span> t1);  <span class="comment">//object</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.info(<span class="string">"t1 instanceof test1--"</span> + (t1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>));   <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.info(<span class="string">"test instanceof Array--"</span> + (test <span class="keyword">instanceof</span> <span class="built_in">Array</span>));  <span class="comment">//false</span></div></pre></td></tr></table></figure>
<ul>
<li><p>第一个：<br>因为 test = 2 先执行了，所以这里 test 的值已经是一个数字了，那么 test.constructr 就是 Number，所以下面这个打印 true；<br>console.log(“test is a Number–” + (test.constructr == Number))</p>
</li>
<li><p>第二个：<br>原因同上，需要注意 typeof 得到的结果 number 的 n 是小写的！</p>
</li>
<li><p>第三个：<br>test1 是一个函数，typeof 值为 function；</p>
</li>
<li><p>第四个：<br>通过 new 得到的结果一定是一个 Object，所以 t1 的 typeof 结果为 object；</p>
</li>
<li><p>第五个：<br>这个题有点误导人的，首先出题人写的是 instanceof test1，但真正计算的却是 instanceof Object，请注意它们的差异！不过不影响结果的，结果都是 true；</p>
</li>
<li><p>第六个：<br>test 是一个数字，所以他的构造函数应是 Number，而不是 Array，所以结果为 false；</p>
</li>
</ul>
<hr>
<p><strong>研究下面 JS 代码是否有问题，有问题请描述问题并解决，没有问题请回答最终结果。</strong></p>
<p>代码一分析:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//申明全局 a，值为 10</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">sayHi();  <span class="comment">//调用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    a = a + <span class="number">10</span>;  <span class="comment">//这里的 a 是全局的 a，而不是局部的，所以执行的结果是把全局 a 设置成了 20</span></div><div class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//20</span></div><div class="line">    <span class="keyword">return</span> a;  <span class="comment">//返回 20</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.info(a);  <span class="comment">//全局 a 已经是 20 了</span></div><div class="line"><span class="built_in">console</span>.info(sayHi() + <span class="number">10</span>);  <span class="comment">//首先又一次执行了 sayHi()，结果把 a 改成了 30，然后打印了一次 30，执行完以后返回了 30，然后在加 10，打印结果 40</span></div></pre></td></tr></table></figure>
<p>代码二分析:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//申明全局 a，值为 10</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="comment">//调用</span></div><div class="line">sayHi();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">/*</span></div><div class="line">注意这里有一个 var，那么这里的 a 就是局部变量了，另外还是需要预解析一下，其实可以这么去看代码：</div><div class="line">var a;   //申明未赋值，默认值是 undefined</div><div class="line">a = a + 10;  // a = undefined + 10 结果是 NaN</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = a + <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.info(a);  <span class="comment">// NaN</span></div><div class="line"><span class="keyword">return</span> a;  <span class="comment">//返回 NaN</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.info(a);  <span class="comment">//这个还是全局的 a，所以结果 10</span></div><div class="line"><span class="built_in">console</span>.info(sayHi() + <span class="number">10</span>); <span class="comment">//依据上面的分析，这里的 sayHi 会打印一次 NaN，然后加 10，结果还是 NaN</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>代码执行结果？详细说明原因？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>)&#125;);</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;;</div><div class="line"><span class="comment">//output: 2，1</span></div></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<p>这里重点是：JQ 的 $(function(){}) 和 window.onload = function(){}，并不等同</p>
<ol>
<li><strong>window.onload </strong>是页面资源加载完成后触发的事件，比如页面中有图片需要加载，那么onload是等图片加载完成以后才触发的。</li>
<li><strong>$(function) </strong>监听的是 DOMContentLoaded 事件，而该事件只需要把 HTML 结构加载完成就会触发（一般我们js操作的就是页面元素，所以只需要等结构加载完成能操作页面元素就可以了）所以该事件会比 onload 事件要先触发，所以 2 先执行。</li>
</ol>
<hr>
<p><strong>请写出以下运算结果：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">alert(<span class="keyword">typeof</span> <span class="literal">null</span>);   <span class="comment">// object</span></div><div class="line"></div><div class="line">alert(<span class="keyword">typeof</span> <span class="literal">undefined</span>);  <span class="comment">// undefined</span></div><div class="line"></div><div class="line">alert(<span class="keyword">typeof</span> <span class="literal">NaN</span>);  <span class="comment">// number</span></div><div class="line"></div><div class="line">alert(<span class="literal">NaN</span> == <span class="literal">undefined</span>);   <span class="comment">// false</span></div><div class="line"></div><div class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>);  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">"123abc"</span>;</div><div class="line"></div><div class="line">alert(<span class="keyword">typeof</span> str++);   <span class="comment">// number</span></div><div class="line"></div><div class="line">alert(str); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>window.foo || (window.foo = “bar”); 返回值是什么？</strong><br><code>&quot;bar&quot;</code></p>
<p>“|| ”又称为短路或，短路：如果左侧为真，则不再进行右侧运算，同时返回左侧表达式运算结果。<br>如果左侧为假则执行右侧表达式运算，并返回右侧计算结果。<br>上面window.foo是不存在的，所有结果为undefined，转成boolean就是false，那么就会运算 window.foo = “bar”，把 “bar” 赋值给 window.foo 的同时，返回值也是 “foo”，所以打印返回结果是 “bar”</p>
<hr>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2017-08-20T18:01:39.000Z" itemprop="dateUpdated">2017-08-21 02:01:39</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/02/28/面试题集锦（JS篇）/" target="_blank" rel="external">http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/</a>
        
    </div>
    <footer>
        <a href="http://kpengWang.github.io">
            <img src="/img/head.jpg" alt="白夜">
            白夜
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试题/">面试题</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/&title=《面试题集锦（JS篇）》 — 白夜的博客&pic=http://kpengWang.github.io/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/&title=《面试题集锦（JS篇）》 — 白夜的博客&source=记录" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试题集锦（JS篇）》 — 白夜的博客&url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/&via=http://kpengWang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/03/01/面试题集锦（发散篇）/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">前端面试题集锦（发散篇）</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/02/28/面试题集锦（CSS篇）/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">面试题集锦（css篇）</h4>
      </a>
    </div>
  
</nav>



    










    <div id="cloud-tie-wrapper" class="comments cloud-tie-wrapper"></div>
    <script>
    var cloudTieConfig = {
        url: 'http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/index.html',
        sourceId: '面试题集锦（JS篇）',
        productKey: 'b9f52fc636224e8b93d9c1ed3db6c5a0',
        target: 'cloud-tie-wrapper',
        pcFiles: [
            '//unpkg.com/hexo-theme-material-indigo@latest/css/cloudTie/pc.css',
            '//unpkg.com/hexo-theme-material-indigo@latest/js/cloudTie/pc.min.js',
        ],
        mobileFiles: [
            '//unpkg.com/hexo-theme-material-indigo@latest/css/cloudTie/mobile.css',
            '//unpkg.com/hexo-theme-material-indigo@latest/js/cloudTie/mobile.min.js'
        ]
    };
    </script>
    <script src="//unpkg.com/hexo-theme-material-indigo@latest/js/cloudTie/loader.min.js"></script>







</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        嗯，请简单粗暴地爱我~
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        <li>
            <img src="/img/wechat.jpg" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/img/alipay.jpg" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>



</div>

        <footer class="footer">
    <!--<div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>-->
    <div class="bottom">
        <p>
            <!--<span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>-->
            <span>Yesterday U Said Tomorrow</span>
            <span>白夜 &copy; 2016 - 2017</span>
        </p>
    </div>
</footer>
    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/&title=《面试题集锦（JS篇）》 — 白夜的博客&pic=http://kpengWang.github.io/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/&title=《面试题集锦（JS篇）》 — 白夜的博客&source=记录" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《面试题集锦（JS篇）》 — 白夜的博客&url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/&via=http://kpengWang.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://kpengWang.github.io/2017/02/28/面试题集锦（JS篇）/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };



</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
