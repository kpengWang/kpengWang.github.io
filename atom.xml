<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白夜的前端技术总结与填坑之旅</title>
  
  <subtitle>KyleWang&#39;s Personal Website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kpeng.wang/"/>
  <updated>2018-08-17T09:48:56.000Z</updated>
  <id>https://kpeng.wang/</id>
  
  <author>
    <name>KyleWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端API设计规范</title>
    <link href="https://kpeng.wang/2018/08/17/%E5%89%8D%E7%AB%AFAPI%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <id>https://kpeng.wang/2018/08/17/前端API设计规范/</id>
    <published>2018-08-17T09:48:30.000Z</published>
    <updated>2018-08-17T09:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-接口的流畅性"><a href="#一-接口的流畅性" class="headerlink" title="一.接口的流畅性"></a>一.接口的流畅性</h2><blockquote><p>好的接口是流畅易懂的，他主要体现如下几个方面</p></blockquote><h3 id="1-简练"><a href="#1-简练" class="headerlink" title="1. 简练"></a>1. 简练</h3><p>操作某个元素的css属性，下面是原生的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'#id'</span>).style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure><p> 封装之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> a  = <span class="function">(<span class="params">selector, color</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelectorAll(selector)[<span class="number">0</span>].style.color = color</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="string">'#a'</span>, <span class="string">'red'</span>)</span><br></pre></td></tr></table></figure><p>从几十个字母长长的一行到简简单单的一个函数调用，体现了api简单易用</p><hr><h3 id="2-可阅读性"><a href="#2-可阅读性" class="headerlink" title="2. 可阅读性"></a>2. 可阅读性</h3><p><code>a(‘#a’, ‘red’)</code>是个好函数，帮助我们简单实用地改变某个元素，但问题来了，如果第一次使用改函数的人来说会比较困惑，a函数是啥函数，没有人告诉他。开发接口有必要知道一点，人都是懒惰的，从颜色赋值这个函数来说，虽然少写了代码，但是增加了记忆成本。每次做这件事情的时候都需要有映射关系。 a—-&gt;color. 如果是简单的几个无所谓，但是通常一套框架都有几十甚至上百的api，映射成本增加会使得程序员哥哥崩溃。 我们需要的就是使得接口有意义，下面我们改写一下a函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> letSomeElementChangeColor  = <span class="function">(<span class="params">selector, color</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelectorAll(selector)[<span class="number">0</span>].style.color = color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elementChangeColor相对于a来说被赋予了语言意义，任何人都会知道它的意义</p><hr><h3 id="3-减少记忆成本"><a href="#3-减少记忆成本" class="headerlink" title="3. 减少记忆成本"></a>3. 减少记忆成本</h3><p>我们刚刚的函数<code>letSomeElementChangeColor</code>也是这样的，它太长了虽然减少了映射成本，但是增加了记忆成本。原生获取dom的api也同样有这个问题 document.getElementsByClassName； document.getElementsByName; document.querySelectorAll;这些api给人的感觉就是单词太长了，虽然他给出的意义是很清晰，然而这种做法是建立在牺牲简易性的基础上进行的。于是我们再次改写这个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export setColor  = (selector, color)=&gt;&#123;</span><br><span class="line">  document.querySelectorAll(selector)[0].style.color = color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-可链式延伸"><a href="#4-可链式延伸" class="headerlink" title="4. 可链式延伸"></a>4. <strong>可链式延伸</strong></h3><p>所谓延伸就是指函数的使用像流水一样按照书写的顺序执行形成执行链条:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'id'</span>).style.color = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'id'</span>).style.fontSize = <span class="string">'12px'</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'id'</span>).style.backgourdColor = <span class="string">'pink'</span></span><br></pre></td></tr></table></figure><ul><li><p>用之前的方法再次封装两个函数 <code>setFontSize</code>, <code>setbackgroundColor</code>; 然后执行它们 setColor(‘id’, ‘red’);setFontSiez(‘id’, ’12px’); setbackgroundColor(‘id’, ‘pink’); </p></li><li><p>这样的做法并没有懒出境界来：</p><ol><li>id元素每次都需要重新获取，影响性能! </li><li>每次都需要添加新的方法</li><li>每次还要调用这些方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetElement</span></span>&#123;</span><br><span class="line">  constractor(selector)&#123;</span><br><span class="line">    <span class="keyword">this</span>.style = <span class="built_in">document</span>.querySelecotrAll(selector).style</span><br><span class="line">  &#125;</span><br><span class="line">  setColor(color)&#123;</span><br><span class="line">     <span class="keyword">this</span>.style.color = color</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  setbackgroundColor(bground)&#123;</span><br><span class="line">    <span class="keyword">this</span>.style.backgroundColor = color</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  setFontSize(size)&#123;</span><br><span class="line">    <span class="keyword">this</span>.style.fontSize = size</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">let</span> el = <span class="keyword">new</span> getElement(<span class="string">'#id'</span>)</span><br><span class="line">el.color(<span class="string">'red'</span>).background(<span class="string">'pink'</span>).fontSize(<span class="string">'12px'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>简单、流畅、易读后面我们会在参数里面讲到如何继续优化。所以，大家都比较喜欢用jquery的api，虽然一个$符号并不代表任何现实意义，但简单的符号有利于我们的使用。它体现了以上的多种原则，简单，易读，易记，链式写法，多参处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'id'</span>).css(&#123;<span class="attr">color</span>:<span class="string">'red'</span>, <span class="attr">fontSize</span>:<span class="string">'12px'</span>, <span class="attr">backgroundColor</span>:<span class="string">'pink'</span>&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="二-接口的一致性"><a href="#二-接口的一致性" class="headerlink" title="二. 接口的一致性"></a>二. 接口的一致性</h2><p>相关的接口保持一致的风格，一整套 API 如果传递一种熟悉和舒适的感觉，会大大减轻开发者对新工具的适应性。 命名这点事：既要短，又要自描述，最重要的是保持一致性 “在计算机科学界只有两件头疼的事：缓存失效和命名问题” — Phil Karlton 选择一个你喜欢的措辞，然后持续使用。选择一种风格，然后保持这种风格。</p><p><strong>good</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setColor;</span><br><span class="line">setBackground;</span><br><span class="line">setFontSize</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setColor ,</span><br><span class="line">letBackGround,</span><br><span class="line">changefontSize,</span><br><span class="line">makedisplay</span><br></pre></td></tr></table></figure><p>尽量地保持代码风格和命名风格，使人读你的代码像是阅读同一个人写的文章一样。</p><hr><h2 id="三-扩展"><a href="#三-扩展" class="headerlink" title="三.扩展"></a>三.扩展</h2><h3 id="1-参数的类型"><a href="#1-参数的类型" class="headerlink" title="1.参数的类型"></a><strong>1.参数的类型</strong></h3><p>判断参数的类型为你的程序提供稳定的保障</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> setColor =<span class="function">(<span class="params">color</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> color !== <span class="string">'string'</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-使用选项参数"><a href="#2-使用选项参数" class="headerlink" title="2.使用选项参数"></a><strong>2.使用选项参数</strong></h3><p>使用选项参数传值很多好处，它可以给参数命名，可以忽略参数的具体位置，可以给参数默认值等等 。</p><p><strong>good</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span>  fn= <span class="function">(<span class="params">option</span>) =&gt;</span>&#123;</span><br><span class="line"><span class="comment">//为必须的参数设置默认值</span></span><br><span class="line">  <span class="keyword">const</span> def = <span class="built_in">Object</span>.assign(&#123;&#125;,&#123;</span><br><span class="line">    param: <span class="string">'default'</span>,</span><br><span class="line">    param1: <span class="string">'default'</span></span><br><span class="line">   &#125;,option)</span><br><span class="line">   <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> fn=<span class="function">(<span class="params">param1, param2........paramN</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-可扩展性"><a href="#3-可扩展性" class="headerlink" title="3.可扩展性"></a>3.<strong>可扩展性</strong></h3><p>软件设计最重要的原则之一：开发封闭原则，也就是永远不修改接口，仅扩展它。可扩展性同时会要求接口的职责单一，多职责的接口很难扩展。 还是拿一个场景来说一下：</p><p><strong>bad</strong></p><p>无法扩展改函数，如果需要再次改变字体的大小的话，只能修改此函数，在函数后面填加改变字体大小的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> set= <span class="function">(<span class="params">selector, color</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el =  <span class="built_in">document</span>.querySelectroAll(selector)</span><br><span class="line">  el.style.color = color</span><br><span class="line">  el.style.backgroundColor = color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>good</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> set= <span class="function">(<span class="params">selector, color</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el =  <span class="built_in">document</span>.querySelectroAll(selector)</span><br><span class="line">  el.style.color = color</span><br><span class="line">  el.style.backgroundColor = color</span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加个设置字体</span></span><br><span class="line"><span class="keyword">export</span> setAgain= <span class="function">(<span class="params">selector, color, px</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> el = set(selector, color)</span><br><span class="line">  el.style.fontSize = px</span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是简单的添加颜色，业务复杂而代码又不是你写的时候，你就必须去阅读之前的代码再修改它，显然是不符合开放-封闭原则的。修改后的function是返回了元素对象，使得下次需要改变时再次得到返回值做处理。</p><hr><h4 id="4-this的运用"><a href="#4-this的运用" class="headerlink" title="4. this的运用"></a>4. <strong>this的运用</strong></h4><p>可扩展性还包括对<code>this</code>的以及<code>call</code>和<code>apply</code>方法的灵活运用。</p><p>顺带说一句，<code>this</code>的优先级</p><p><code>let f = new Foo()</code>  &gt; <code>call</code>,<code>apply</code>,<code>bind</code>&gt;<code>obj.Foo()</code>&gt;<code>Foo()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayBonjour</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">obj.a = <span class="number">1</span></span><br><span class="line">obj.say = sayBonjour</span><br><span class="line">obj.say() <span class="comment">//1</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">sayBonjour.call||apply(obj)<span class="comment">//1</span></span><br></pre></td></tr></table></figure><hr><h2 id="四-对错误的处理"><a href="#四-对错误的处理" class="headerlink" title="四.对错误的处理"></a>四.对错误的处理</h2><h3 id="1-预见错误"><a href="#1-预见错误" class="headerlink" title="1.预见错误"></a><strong>1.预见错误</strong></h3><p>可以用 类型检测 typeof 或者try…catch。 typeof 会强制检测对象不抛出错误，对于未定义的变量尤其有用。</p><hr><h3 id="2-抛出错误"><a href="#2-抛出错误" class="headerlink" title="2.抛出错误"></a><strong>2.抛出错误</strong></h3><p>大多数开发者不希望出错了还需要自己去找带对应得代码，最好方式是直接在console中输出，告诉用户发生了什么事情。我们可以用到浏览器的输出api:console.log/warn/error。你还可以为自己的程序留些后路: try…catch。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> error= <span class="function">(<span class="params">a</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> a !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'param a must be type of string'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> error()=&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// some code excucete here maybe throw wrong</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.wran(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-可预见性"><a href="#3-可预见性" class="headerlink" title="3.可预见性"></a><strong>3.可预见性</strong></h3><p>可预见性味程序接口提供健壮性，为保证你的代码顺利执行，必须为它考虑到非正常预期的情况。我们看下不可以预见的代码和可预见的代码的区别，还是用之前的setColor。</p><p><strong>bad</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> set(selector, color)=&gt; &#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(selector).style.color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>good</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dom</span><br><span class="line">  <span class="comment">// If nothing given, return an empty Zepto collection</span></span><br><span class="line">  <span class="keyword">if</span> (!selector) <span class="keyword">return</span> zepto.Z()</span><br><span class="line">  <span class="comment">// Optimize for string selectors</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">'string'</span>) &#123;</span><br><span class="line">    selector = selector.trim()</span><br><span class="line">    <span class="comment">// If it's a html fragment, create nodes from it</span></span><br><span class="line">    <span class="comment">// Note: In both Chrome 21 and Firefox 15, DOM error 12</span></span><br><span class="line">    <span class="comment">// is thrown if the fragment doesn't begin with &lt;</span></span><br><span class="line">    <span class="keyword">if</span> (selector[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; fragmentRE.test(selector))</span><br><span class="line">      dom = zepto.fragment(selector, <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// If there's a context, create a collection on that context first, and select</span></span><br><span class="line">    <span class="comment">// nodes from there</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</span><br><span class="line">    <span class="comment">// If it's a CSS selector, use it to select nodes.</span></span><br><span class="line">    <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If a function is given, call it when the DOM is ready</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(selector)) <span class="keyword">return</span> $(<span class="built_in">document</span>).ready(selector)</span><br><span class="line">  <span class="comment">// If a Zepto collection is given, just return it</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (zepto.isZ(selector)) <span class="keyword">return</span> selector</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normalize array if an array of nodes is given</span></span><br><span class="line">    <span class="keyword">if</span> (isArray(selector)) dom = compact(selector)</span><br><span class="line">    <span class="comment">// Wrap DOM nodes.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isObject(selector))</span><br><span class="line">      dom = [selector], selector = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// If it's a html fragment, create nodes from it</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fragmentRE.test(selector))</span><br><span class="line">      dom = zepto.fragment(selector.trim(), <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// If there's a context, create a collection on that context first, and select</span></span><br><span class="line">    <span class="comment">// nodes from there</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</span><br><span class="line">    <span class="comment">// And last but no least, if it's a CSS selector, use it to select nodes.</span></span><br><span class="line">    <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// create a new Zepto collection from the nodes found</span></span><br><span class="line">  <span class="keyword">return</span> zepto.Z(dom, selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是zepto的源码，可以看见，作者在预见传入的参数时做了很多的处理。其实可预见性是为程序提供了若干的入口，无非是一些逻辑判断而已。zepto在这里使用了很多的是非判断，同时导致了代码的冗长，不适合阅读。总之，可预见性真正需要你做的事多写一些对位置实物的参数。把外部的检测改为内部检测。</p><hr><h2 id="五-注释和文档的可读性"><a href="#五-注释和文档的可读性" class="headerlink" title="五.注释和文档的可读性"></a><strong>五.注释和文档的可读性</strong></h2><p>一个最好的接口是不需要文档我们也会使用它，但是往往接口量一多和业务增加，接口使用起来也会有些费劲。所以接口文档和注释是需要认真书写的。注释遵循简单扼要地原则，给多年后的自己也给后来者看，在关键和有歧义的地方写上注释，犹如画龙点睛，这里再次推荐一下VS code 的<strong>Document This</strong> 插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  将数组块划分为指定大小的较小数组。</span></span><br><span class="line"><span class="comment"> * “使用Array.from()创建新的数组, 这符合将生成的区块数。使用Array.slice()将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。”</span></span><br><span class="line"><span class="comment"> * @param &#123;需要传入的数组&#125; arr</span></span><br><span class="line"><span class="comment"> * @param &#123;返回的数组粒度大小&#125; size</span></span><br><span class="line"><span class="comment"> * Example: chunk([1,2,3,4,5], 2) -&gt; [[1,2],[3,4],[5]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> chunk = <span class="function">(<span class="params">arr, size</span>) =&gt;</span> <span class="built_in">Array</span>.from(&#123;</span><br><span class="line">    length: <span class="built_in">Math</span>.ceil(arr.length / size)</span><br><span class="line">&#125;, (v, i) =&gt; arr.slice(i * size, i * size + size))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-接口的流畅性&quot;&gt;&lt;a href=&quot;#一-接口的流畅性&quot; class=&quot;headerlink&quot; title=&quot;一.接口的流畅性&quot;&gt;&lt;/a&gt;一.接口的流畅性&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;好的接口是流畅易懂的，他主要体现如下几个方面&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
      <category term="开发规范" scheme="https://kpeng.wang/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发规范</title>
    <link href="https://kpeng.wang/2018/08/17/Vue%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://kpeng.wang/2018/08/17/Vue开发规范/</id>
    <published>2018-08-17T09:37:59.000Z</published>
    <updated>2018-08-17T09:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强制"><a href="#强制" class="headerlink" title="强制"></a>强制</h2><h4 id="1-组件名为多个单词驼峰形式"><a href="#1-组件名为多个单词驼峰形式" class="headerlink" title="1. 组件名为多个单词驼峰形式"></a>1. 组件名为多个单词<strong>驼峰</strong>形式</h4><blockquote><p>组件名应该始终是多个单词的，根组件 App 除外</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'TodoItem'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Todo'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-组件数据"><a href="#2-组件数据" class="headerlink" title="2. 组件数据"></a>2. 组件数据</h4><blockquote><p>==组件的 data 必须是一个函数。==<br>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// In a .vue file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在一个 Vue 的根实例上直接使用对象是可以的，</span></span><br><span class="line"><span class="comment">// 因为只存在一个这样的实例。</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-Props定义"><a href="#3-Props定义" class="headerlink" title="3. Props定义"></a>3. Props定义</h4><blockquote><p>Prop 定义应该尽量详细。<br>在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">  status: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更完善的做法，加强代码健壮性</span></span><br><span class="line">props: &#123;</span><br><span class="line">     status: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function">(<span class="params">value</span>) =&gt;</span> [<span class="string">'syncing'</span>, <span class="string">'synced'</span>, <span class="string">'version-conflict'</span>, <span class="string">'error'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这样做只有开发原型系统时可以接受</span></span><br><span class="line">props: [<span class="string">'status'</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="4-为v-for设置key值"><a href="#4-为v-for设置key值" class="headerlink" title="4. 为v-for设置key值"></a>4. 为v-for设置key值</h4><blockquote><p>总是用 key 配合 v-for。<br>在组件上_总是_必须用 key 配合 v-for，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的对象固化 (object constancy)，也是一种好的做法。</p></blockquote><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"todo in todos"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="5-避免v-if与v-for在同一标签上使用"><a href="#5-避免v-if与v-for在同一标签上使用" class="headerlink" title="5. 避免v-if与v-for在同一标签上使用"></a>5. 避免v-if与v-for在同一标签上使用</h4><blockquote><p>永远不要把 v-if 和 v-for 同时用在同一个元素上。<br>一般我们在两种常见的情况下会倾向于这样做：</p></blockquote><ul><li>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</li><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul, ol)。</li></ul><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"shouldShowUsers"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"user in users"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"user.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"user in users"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"shouldShowUsers"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"user.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="6-为组件样式设置scope"><a href="#6-为组件样式设置scope" class="headerlink" title="6. 为组件样式设置scope"></a>6. 为组件样式设置scope</h4><blockquote><p>对于应用来说，顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。<br>这条规则只和单文件组件有关。你不一定要使用 scoped 特性。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然你也可以使用其它的库或约定。<br><strong>不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 scoped 特性</strong>。<br>这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button button-close"</span>&gt;</span>X<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>good</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 使用 BEM 约定 --&gt;</span><br><span class="line">&lt;style lang=<span class="string">"stylus"</span>&gt;</span><br><span class="line"><span class="selector-class">.c-Button</span> </span><br><span class="line">  <span class="attribute">border</span> none</span><br><span class="line">  <span class="attribute">border-radius</span> <span class="number">2px</span></span><br><span class="line"><span class="selector-class">.c-Button--close</span> </span><br><span class="line">  <span class="attribute">background-color</span> red</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style  lang=<span class="string">"stylus"</span> scoped&gt;</span><br><span class="line"><span class="selector-class">.button</span> </span><br><span class="line">  <span class="attribute">border</span> none</span><br><span class="line">  <span class="attribute">border-radius</span> <span class="number">2px</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button-close</span> </span><br><span class="line">  <span class="attribute">background-color</span> red</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><h4 id="1-组件文件"><a href="#1-组件文件" class="headerlink" title="1.组件文件"></a>1.组件文件</h4><blockquote><p>只要有能够拼接文件的构建系统，就把每个组件单独分成文件。<br>当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。</p></blockquote><p><strong>good</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoItem.vue</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'TodoList'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'TodoItem'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h4 id="2-单文件组件文件的大小写"><a href="#2-单文件组件文件的大小写" class="headerlink" title="2.单文件组件文件的大小写"></a>2.单文件组件文件的大小写</h4><blockquote><p>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- MyComponent.vue</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- myComponent.vue</span><br><span class="line">|- mycomponent.vue</span><br></pre></td></tr></table></figure><hr><h4 id="3-基础组件名"><a href="#3-基础组件名" class="headerlink" title="3.基础组件名"></a>3.基础组件名</h4><blockquote><p>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- BaseButton.vue</span><br><span class="line">|- BaseTable.vue</span><br><span class="line">|- BaseIcon.vue</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- MyButton.vue</span><br><span class="line">|- VueTable.vue</span><br><span class="line">|- Icon.vue</span><br></pre></td></tr></table></figure><hr><h4 id="4-单例组件名"><a href="#4-单例组件名" class="headerlink" title="4.单例组件名"></a>4.单例组件名</h4><blockquote><p>只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。<br>这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的，而不是它们在你的应用中的上下文。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，只是目前在每个页面里只使用一次。</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TheHeading.vue</span><br><span class="line">|- TheSidebar.vue</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- Heading.vue</span><br><span class="line">|- MySidebar.vue</span><br></pre></td></tr></table></figure><hr><h4 id="5-紧密耦合的组件名"><a href="#5-紧密耦合的组件名" class="headerlink" title="5.紧密耦合的组件名"></a>5.紧密耦合的组件名</h4><blockquote><p>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。<br>如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoListItem.vue</span><br><span class="line">|- TodoListItemButton.vue</span><br><span class="line">components/</span><br><span class="line">|- SearchSidebar.vue</span><br><span class="line">|- SearchSidebarNavigation.vue</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- SearchSidebar.vue</span><br><span class="line">|- NavigationForSearchSidebar.vue</span><br></pre></td></tr></table></figure><hr><h4 id="6-组件名中的单词顺序"><a href="#6-组件名中的单词顺序" class="headerlink" title="6.组件名中的单词顺序"></a>6.组件名中的单词顺序</h4><blockquote><p>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- SearchButtonClear.vue</span><br><span class="line">|- SearchButtonRun.vue</span><br><span class="line">|- SearchInputQuery.vue</span><br><span class="line">|- SearchInputExcludeGlob.vue</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- ClearSearchButton.vue</span><br><span class="line">|- ExcludeFromSearchInput.vue</span><br><span class="line">|- LaunchOnStartupCheckbox.vue</span><br><span class="line">|- RunSearchButton.vue</span><br><span class="line">|- SearchInput.vue</span><br><span class="line">|- TermsCheckbox.vue</span><br></pre></td></tr></table></figure><hr><h4 id="7-模版中的组件名大小写"><a href="#7-模版中的组件名大小写" class="headerlink" title="7.模版中的组件名大小写"></a>7.模版中的组件名大小写</h4><blockquote><p>保持烤串写法</p></blockquote><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycomponent</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="8-完整单词的组件名"><a href="#8-完整单词的组件名" class="headerlink" title="8.完整单词的组件名"></a>8.完整单词的组件名</h4><blockquote><p>组件名应该倾向于完整有意义的单词而不是缩写。</p></blockquote><p><strong>good</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- StudentDashboardSettings.vue</span><br><span class="line">|- UserProfileOptions.vue</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- SdSettings.vue</span><br><span class="line">|- UProfOpts.vue</span><br></pre></td></tr></table></figure><hr><h4 id="9-多个特性的元素"><a href="#9-多个特性的元素" class="headerlink" title="9.多个特性的元素"></a>9.多个特性的元素</h4><blockquote><p>多个特性的元素应该分多行撰写，每个特性一行。</p></blockquote><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://vuejs.org/images/logo.png"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">"Vue Logo"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">foo</span>=<span class="string">"a"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">bar</span>=<span class="string">"b"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">baz</span>=<span class="string">"c"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://vuejs.org/images/logo.png"</span> <span class="attr">alt</span>=<span class="string">"Vue Logo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">foo</span>=<span class="string">"a"</span> <span class="attr">bar</span>=<span class="string">"b"</span> <span class="attr">baz</span>=<span class="string">"c"</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="10-模版中简单的表达式"><a href="#10-模版中简单的表达式" class="headerlink" title="10.模版中简单的表达式"></a>10.模版中简单的表达式</h4><blockquote><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。<br>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p></blockquote><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; normalizedFullName &#125;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复杂表达式已经移入一个计算属性</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedFullName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fullName.split(<span class="string">' '</span>).map(<span class="function">(<span class="params">word</span>)=&gt;</span>word[<span class="number">0</span>].toUpperCase() + word.slice(<span class="number">1</span>)&#125;).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  在差值表达式里直接写入逻辑--&gt;</span></span><br><span class="line">&#123;&#123; fullName.split(' ').map((word)=&gt;word[0].toUpperCase() + word.slice(1) &#125;&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="11-简单的计算属性"><a href="#11-简单的计算属性" class="headerlink" title="11.简单的计算属性"></a>11.简单的计算属性</h4><blockquote><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。<br>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p></blockquote><p><strong>good</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  basePrice () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.manufactureCost / (<span class="number">1</span> - <span class="keyword">this</span>.profitMargin)</span><br><span class="line">  &#125;,</span><br><span class="line">  discount &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.basePrice * (<span class="keyword">this</span>.discountPercent || <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  finalPrice &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.basePrice - <span class="keyword">this</span>.discount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  price () &#123;</span><br><span class="line">    <span class="keyword">let</span> basePrice = <span class="keyword">this</span>.manufactureCost / (<span class="number">1</span> - <span class="keyword">this</span>.profitMargin)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      basePrice -</span><br><span class="line">      basePrice * (<span class="keyword">this</span>.discountPercent || <span class="number">0</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="12-带引号的特性值"><a href="#12-带引号的特性值" class="headerlink" title="12.带引号的特性值"></a>12.带引号的特性值</h4><blockquote><p>非空 HTML 特性值应该始终带引号 (单引号或双引号，选你 JS 里不用的那个)。<br>在 HTML 中不带空格的特性值是可以没有引号的，但这样做常常导致带空格的特征值被回避，导致其可读性变差。</p></blockquote><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-sidebar</span> <span class="attr">:style</span>=<span class="string">"&#123; width: sidebarWidth + 'px' &#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-sidebar</span> <span class="attr">:style</span>=<span class="string">&#123;width:sidebarWidth+</span>'<span class="attr">px</span>'&#125;&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="13-指令缩写"><a href="#13-指令缩写" class="headerlink" title="13.指令缩写"></a>13.指令缩写</h4><blockquote><p>都用指令缩写 (用 <code>:</code> 表示 <code>v-bind</code> 和用<code>@</code>表示 <code>v-on</code>:)</p></blockquote><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">"onInput"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">"onFocus"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>bad</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:placeholder</span>=<span class="string">"newTodoInstructions"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="14-单文件组件的顶级元素"><a href="#14-单文件组件的顶级元素" class="headerlink" title="14.单文件组件的顶级元素"></a>14.单文件组件的顶级元素</h4><blockquote><p>单文件组件应该总是让<script>、<template> 和 <style> 标签的顺序保持一致。且 <style> 要放在最后，因为另外两个标签至少要有一个。</p></blockquote><p><strong>good</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- example.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span>...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="comment">/* ... */</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">/* ... */</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>–</p><h2 id="慎用"><a href="#慎用" class="headerlink" title="慎用"></a>慎用</h2><h4 id="1-未在v-if-v-else-v-if-else中使用key"><a href="#1-未在v-if-v-else-v-if-else中使用key" class="headerlink" title="1.未在v-if/v-else/v-if-else中使用key"></a>1.未在v-if/v-else/v-if-else中使用key</h4><blockquote><p>如果一组 <code>v-if</code> + <code>v-else</code> 的元素类型相同，最好使用 <code>key</code> (比如两个 <div> 元素)。</p></blockquote><p><strong>good</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  v-if=&quot;error&quot;</span><br><span class="line">  key=&quot;search-status&quot;</span><br><span class="line">&gt;</span><br><span class="line">  错误：&#123;&#123; error &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div</span><br><span class="line">  v-else</span><br><span class="line">  key=&quot;search-results&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123; results &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><strong>bad</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;error&quot;&gt;</span><br><span class="line">  错误：&#123;&#123; error &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  &#123;&#123; results &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><hr><h4 id="2-scoped中的元素选择器"><a href="#2-scoped中的元素选择器" class="headerlink" title="2.scoped中的元素选择器"></a>2.scoped中的元素选择器</h4><blockquote><p>元素选择器应该避免在 scoped 中出现。<br>在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。</p></blockquote><p><strong>good</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">.btn-close </span><br><span class="line">  background-color red</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button&gt;X&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;stylus&quot; scoped&gt;</span><br><span class="line">button </span><br><span class="line">  background-color red</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><hr><h4 id="3-隐性的父子组件通信"><a href="#3-隐性的父子组件通信" class="headerlink" title="3.隐性的父子组件通信"></a>3.隐性的父子组件通信</h4><blockquote><p>应该优先通过<code>prop</code> 和事件进行父子组件之间的通信，而不是 <code>this.$parent</code> 或改变<code>prop</code>。</p></blockquote><p><strong>good</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'TodoItem'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    todo: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      :value="todo.text"</span></span><br><span class="line"><span class="string">      @input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'TodoItem'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    todo: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    removeTodo () &#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      vm.$parent.todos = vm.$parent.todos.filter(<span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> todo.id !== vm.todo.id</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;span&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; todo.text &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;button @click="removeTodo"&gt;</span></span><br><span class="line"><span class="string">        X</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/span&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h4 id="4-非Flux的全局状态管理"><a href="#4-非Flux的全局状态管理" class="headerlink" title="4.非Flux的全局状态管理"></a>4.非Flux的全局状态管理</h4><blockquote><p>应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。</p></blockquote><p><strong>good</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/modules/todos.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: []</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    REMOVE_TODO (state, todoId) &#123;</span><br><span class="line">      state.list = state.list.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== todoId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    removeTodo (&#123; commit, state &#125;, todo) &#123;</span><br><span class="line">      commit(<span class="string">'REMOVE_TODO'</span>, todo.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- TodoItem.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    &lt;button @click=&quot;removeTodo(todo)&quot;&gt;</span><br><span class="line">      X</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    todo: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      required: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">      ...mapActions([&apos;removeTodo&apos;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>bad</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: []</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$on(<span class="string">'remove-todo'</span>, <span class="keyword">this</span>.removeTodo)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    removeTodo: <span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> todoIdToRemove = todo.id</span><br><span class="line">      <span class="keyword">this</span>.todos = <span class="keyword">this</span>.todos.filter(<span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> todo.id !== todoIdToRemove</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="安利"><a href="#安利" class="headerlink" title="安利"></a>安利</h2><h4 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a><strong>VS Code</strong></h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><blockquote><p>推荐使用vscode进行vue开发，以下是我的开发环境配置文件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*编辑器设置*/</span></span><br><span class="line">  <span class="string">"editor.tabSize"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">"editor.fontSize"</span>: <span class="number">16</span>,</span><br><span class="line">  <span class="string">"editor.fontFamily"</span>: <span class="string">"Menlo,Consolas, monospace"</span>,</span><br><span class="line">  <span class="string">"editor.renderWhitespace"</span>: <span class="string">"boundary"</span>,</span><br><span class="line">  <span class="string">"editor.cursorBlinking"</span>: <span class="string">"smooth"</span>,</span><br><span class="line">  <span class="string">"editor.renderIndentGuides"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*工作区设置*/</span></span><br><span class="line">  <span class="string">"workbench.editor.enablePreview"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"workbench.colorTheme"</span>: <span class="string">"Dracula"</span>,</span><br><span class="line">  <span class="string">"workbench.startupEditor"</span>: <span class="string">"newUntitledFile"</span>,</span><br><span class="line">  <span class="string">"workbench.iconTheme"</span>: <span class="string">"vscode-icons"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*文件设置*/</span></span><br><span class="line">  <span class="string">"files.associations"</span>: &#123;</span><br><span class="line">    <span class="string">"*.vue"</span>: <span class="string">"vue"</span>,</span><br><span class="line">    <span class="string">"*.wpy"</span>: <span class="string">"vue"</span>,</span><br><span class="line">    <span class="string">"*.wxml"</span>: <span class="string">"html"</span>,</span><br><span class="line">    <span class="string">"*.wxss"</span>: <span class="string">"css"</span>,</span><br><span class="line">    <span class="string">"*.cjson"</span>: <span class="string">"jsonc"</span>,</span><br><span class="line">    <span class="string">"*.wxs"</span>: <span class="string">"javascript"</span>,</span><br><span class="line">    <span class="string">"*.wxa"</span>: <span class="string">"vue"</span>,</span><br><span class="line">    <span class="string">"*.wx"</span>: <span class="string">"vue"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"files.autoSave"</span>: <span class="string">"onFocusChange"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置ESlint*/</span></span><br><span class="line">  <span class="string">"eslint.autoFixOnSave"</span>: <span class="literal">true</span>, <span class="comment">//保存自动修复</span></span><br><span class="line">  <span class="string">"eslint.options"</span>: &#123;</span><br><span class="line">    <span class="string">"extensions"</span>: [</span><br><span class="line">      <span class="string">".js"</span>,</span><br><span class="line">      <span class="string">".vue"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">      <span class="string">"html"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"eslint.validate"</span>: [</span><br><span class="line">    <span class="string">"javascript"</span>,</span><br><span class="line">    <span class="string">"javascriptreact"</span>,</span><br><span class="line">    <span class="string">"html"</span>,</span><br><span class="line">    <span class="string">"vue"</span>,</span><br><span class="line">    <span class="string">"vue-html"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"language"</span>: <span class="string">"html"</span>,</span><br><span class="line">      <span class="string">"autoFix"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*格式化vue*/</span></span><br><span class="line">  <span class="string">"vetur.validation.template"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"vetur.format.defaultFormatter.html"</span>: <span class="string">"js-beautify-html"</span>,</span><br><span class="line">  <span class="string">"vetur.format.defaultFormatter.js"</span>: <span class="string">"vscode-typescript"</span>,</span><br><span class="line">  <span class="string">"vetur.format.defaultFormatterOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"js-beautify-html"</span>: &#123;</span><br><span class="line">      <span class="string">"wrap_attributes"</span>: <span class="string">"force-aligned"</span></span><br><span class="line">      <span class="comment">// 属性换行，可以换成任意一种 [auto|force|force-aligned|force-expand-multiline] ["auto"]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"vetur.extensions"</span>: [</span><br><span class="line">    <span class="string">".wxa"</span>,</span><br><span class="line">    <span class="string">".wx"</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="string">"prettier.semi"</span>: <span class="literal">false</span>, <span class="comment">// 每一行末尾加上分号</span></span><br><span class="line">  <span class="string">"prettier.singleQuote"</span>: <span class="literal">true</span>, <span class="comment">// 用单引号</span></span><br><span class="line">  <span class="string">"prettier.printWidth"</span>: <span class="number">200</span>, <span class="comment">// 换行字符串阈值</span></span><br><span class="line">  <span class="string">"prettier.trailingComma"</span>: <span class="string">"none"</span>, <span class="comment">// (x) =&gt; &#123;&#125; 是否要有小括号</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"beautify.config"</span>: &#123;</span><br><span class="line">    <span class="string">"brace_style"</span>: <span class="string">"none,preserve-inline"</span>,</span><br><span class="line">    <span class="string">"indent_size"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"indent_char"</span>: <span class="string">" "</span>,</span><br><span class="line">    <span class="string">"jslint_happy"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"unformatted"</span>: [<span class="string">""</span>],</span><br><span class="line">    <span class="string">"css"</span>: &#123;</span><br><span class="line">      <span class="string">"indent_size"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*格式化stylus*/</span></span><br><span class="line">  <span class="string">"stylusSupremacy.insertColons"</span>: <span class="literal">false</span>, <span class="comment">// 是否插入冒号</span></span><br><span class="line">  <span class="string">"stylusSupremacy.insertSemicolons"</span>: <span class="literal">false</span>, <span class="comment">// 是否插入分号</span></span><br><span class="line">  <span class="string">"stylusSupremacy.insertBraces"</span>: <span class="literal">false</span>, <span class="comment">// 是否插入大括号</span></span><br><span class="line">  <span class="string">"stylusSupremacy.insertNewLineAroundImports"</span>: <span class="literal">false</span>, <span class="comment">// import之后是否换行</span></span><br><span class="line">  <span class="string">"stylusSupremacy.insertNewLineAroundBlocks"</span>: <span class="literal">false</span>, <span class="comment">// 两个选择器中是否换行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置Git相关*/</span></span><br><span class="line">  <span class="string">"gitlens.advanced.messages"</span>: &#123;</span><br><span class="line">    <span class="string">"suppressShowKeyBindingsNotice"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"suppressUpdateNotice"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"git.ignoreMissingGitWarning"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"gitlens.keymap"</span>: <span class="string">"alternate"</span>,</span><br><span class="line">  <span class="string">"gitlens.historyExplorer.enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"git.ignoreLimitWarning"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/*其它功能*/</span></span><br><span class="line">  <span class="string">"fileheader.Author"</span>: <span class="string">"KyleWang"</span>,</span><br><span class="line">  <span class="string">"fileheader.LastModifiedBy"</span>: <span class="string">"KyleWang"</span>,</span><br><span class="line">  <span class="string">"window.zoomLevel"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"explorer.confirmDelete"</span>: <span class="literal">false</span>, <span class="comment">//删除文件是否弹出系统资源管理器的删除提示框</span></span><br><span class="line">  <span class="string">"material-icon-theme.showUpdateMessage"</span>: <span class="literal">false</span>, <span class="comment">//禁止图标更新弹出更新信息</span></span><br><span class="line">  <span class="string">"vsicons.dontShowNewVersionMessage"</span>: <span class="literal">true</span>, <span class="comment">//禁止图标更新弹出更新信息</span></span><br><span class="line">  <span class="string">"touchuiwx.enable"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"search.exclude"</span>: &#123; <span class="comment">// 搜索过滤掉</span></span><br><span class="line">    <span class="string">"**/node_modules"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"**/bower_components"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"**/dist"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"emmet.syntaxProfiles"</span>: &#123;</span><br><span class="line">    <span class="string">"javascript"</span>: <span class="string">"jsx"</span>,</span><br><span class="line">    <span class="string">"vue"</span>: <span class="string">"html"</span>,</span><br><span class="line">    <span class="string">"vue-html"</span>: <span class="string">"html"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"extensions.autoUpdate"</span>: <span class="literal">true</span>, <span class="comment">//自动更新扩展</span></span><br><span class="line">  <span class="string">"terminal.integrated.shell.windows"</span>: <span class="string">"D:\\Program Files\\git\\bin\\bash.exe"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置同步*/</span></span><br><span class="line">  <span class="string">"sync.gist"</span>: <span class="string">"45dc1212a1f379bc5ba424cac0d84e27"</span>,</span><br><span class="line">  <span class="string">"sync.lastUpload"</span>: <span class="string">"2018-08-01T12:39:05.866Z"</span>,</span><br><span class="line">  <span class="string">"sync.autoDownload"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"sync.autoUpload"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"sync.lastDownload"</span>: <span class="string">"2018-07-12T16:43:12.208Z"</span>,</span><br><span class="line">  <span class="string">"sync.forceDownload"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"sync.host"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"sync.pathPrefix"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"sync.quietSync"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"sync.askGistName"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"sync.removeExtensions"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"sync.syncExtensions"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"material-icon-theme.folders.theme"</span>: <span class="string">"specific"</span>,</span><br><span class="line">  <span class="string">"emmet.includeLanguages"</span>: &#123;</span><br><span class="line">    <span class="string">"wxml"</span>: <span class="string">"html"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"minapp-vscode.disableAutoConfig"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"javascript.updateImportsOnFileMove.enabled"</span>: <span class="string">"always"</span>,</span><br><span class="line">  <span class="string">"explorer.confirmDragAndDrop"</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h5><table><thead><tr><th>插件名</th><th>作用</th></tr></thead><tbody><tr><td>Auto Close Tag</td><td>自动闭合HTML/XML标签</td></tr><tr><td>Auto Import</td><td>自动导入模块</td></tr><tr><td>Auto Rename Tag</td><td>自动完成另一侧标签的同步修改</td></tr><tr><td>Axios Snippets</td><td>axios 语法提示</td></tr><tr><td>Beautify</td><td>格式化 支持自定义格式化代码规则</td></tr><tr><td>Better Comments</td><td>文件注释</td></tr><tr><td>Bookmarks</td><td>添加行书签</td></tr><tr><td>Bracket Pair Colorizer</td><td>给括号加上不同的颜色，便于区分不同的区块</td></tr><tr><td>BreadCrumb in StatusBar</td><td>编辑器底部显示当前文件面包屑</td></tr><tr><td>Can I Use</td><td>HTML5、CSS3、SVG的浏览器兼容性检查</td></tr><tr><td>Chinese(Simplified) Language</td><td>编辑器汉化</td></tr><tr><td>Class autocomplete for HTML</td><td>智能提示HTML class</td></tr><tr><td>Code Runner</td><td>运行选中代码段（支持大量语言，包括Node）</td></tr><tr><td>Color Highlight</td><td>颜色值在代码中高亮显示</td></tr><tr><td>Color Picke</td><td>拾色器</td></tr><tr><td>csscomb</td><td>css排序格式化</td></tr><tr><td>Css peek</td><td>追踪至样式表中 CSS 类和ID定义的地方</td></tr><tr><td>Debugger for Chrome</td><td>映射vscode上的断点到chrome上，方便调试</td></tr><tr><td>Document This</td><td>Js的注释模板</td></tr><tr><td>Docker</td><td>编辑器支持识别doker语法</td></tr><tr><td>EditorConfig for vs code</td><td>协同办公， 保持编码风格的一致</td></tr><tr><td>ES7 React/Redux…</td><td>react,GraphQL,react-native代码段</td></tr><tr><td>EsLint</td><td>es语法纠错，可以自定义配置</td></tr><tr><td>File Peek</td><td>根据路径字符串，快速定位到文件</td></tr><tr><td>filesize</td><td>在底部状态栏显示当前文件大小，点击后还可以看到详细创建、修改时间</td></tr><tr><td>Font-awesome codes</td><td>font-awesome字体库提示</td></tr><tr><td>Git Blame</td><td>在状态栏显示当前行的Git信息</td></tr><tr><td>Git History</td><td>方便查看git日志，git重度使用者必备</td></tr><tr><td>GitLens</td><td>显示文件最近的commit和作者，显示当前行commit信息</td></tr><tr><td>Guides</td><td>高亮缩进基准线</td></tr><tr><td>Gulp Snippets</td><td>Gulp智能提示代码段</td></tr><tr><td>HTML CSS Support</td><td>css提示（支持vue）</td></tr><tr><td>HTML Snippets</td><td>智能提示HTML标签，以及标签含义</td></tr><tr><td>HTMLHin</td><td>HTML 语法纠错</td></tr><tr><td>htmltagwrap</td><td>html标签快捷键包裹</td></tr><tr><td>indent-rainbow</td><td>会给缩进添加一种颜色,更加直观的看到代码层次</td></tr><tr><td>Indenticator</td><td>缩进高亮</td></tr><tr><td>Import Cos</td><td>引入包大小计算,对于项目打包后体积掌握很有帮助</td></tr><tr><td>IntelliSense for Css class names in HTML</td><td>智能提示 css 的 class 名</td></tr><tr><td>JavaScript (ES6) code snippets</td><td>ES6语法智能提示</td></tr><tr><td>JavaScript snippet Pack</td><td>一个片段包</td></tr><tr><td>JavaScript standardjs styled snippets</td><td>statard风格的代码段提示</td></tr><tr><td>jQuery Code Snippets</td><td>jQuery代码智能提示</td></tr><tr><td>Json Editor</td><td>折叠格式化</td></tr><tr><td>Json Helper</td><td>提供大纲功能,可以快速跳转编辑</td></tr><tr><td>language-stylus</td><td>支持stylus</td></tr><tr><td>Live HTML Previewer</td><td>html文件运行预览</td></tr><tr><td>Live Server</td><td>启服务，可配置编辑</td></tr><tr><td>Lodash Snippets</td><td>Lodash代码段</td></tr><tr><td>Manta’s Stylus Supremacy</td><td>stylus语法识别和风格编辑</td></tr><tr><td>Markdown Preview Enhanced</td><td>实时预览markdown</td></tr><tr><td>markdownlint</td><td>markdown语法纠错</td></tr><tr><td>minapp</td><td>小程序语法提示</td></tr><tr><td>minify</td><td>压缩合并 JavaScript 和 CSS 文件</td></tr><tr><td>mpvue snippets</td><td>mpvue代码段提示</td></tr><tr><td>Node.js Modules Intellisense</td><td>可以在导入语句中自动完成JavaScript / TypeScript模块</td></tr><tr><td>Node modules resolve</td><td>快速导航到Node模块</td></tr><tr><td>npm</td><td>运行npm命令</td></tr><tr><td>npm Intellisense</td><td>导入模块时，提示已安装模块名称</td></tr><tr><td>open in browser</td><td>支持快捷键与鼠标右键快速在浏览器中打开html文件</td></tr><tr><td>Output Colorizer</td><td>颜色输出信息</td></tr><tr><td>Partial Diff</td><td>diff文件比较</td></tr><tr><td>Path Autocomplete</td><td>自动完善路由</td></tr><tr><td>Path Intellisense</td><td>自动提示文件路径，支持各种快速引入文件</td></tr><tr><td>Polacode</td><td>代码截图导出</td></tr><tr><td>Prettier -Code formmatter</td><td>代码格式化程序</td></tr><tr><td>Prettify JSON</td><td>格式化JSON</td></tr><tr><td>Project Manager</td><td>快速切换项目</td></tr><tr><td>Projects+</td><td>项目管理必备插件,可以快速录入本地项目的地址,打开</td></tr><tr><td>Quokka.js</td><td>调试工具插件，能够根据你正在编写的代码提供实时反馈。</td></tr><tr><td>React Native Tools</td><td>可以进行断点调试 React Native</td></tr><tr><td>React-Native/React/Redux snippets</td><td>React/Redux/react-router语法智能提示</td></tr><tr><td>REST Client</td><td>发送REST风格的HTTP请求</td></tr><tr><td>Sass</td><td>sass支持</td></tr><tr><td>Settings Sync</td><td>VSCode设置同步到Gist</td></tr><tr><td>Sort lines</td><td>排序选中行</td></tr><tr><td>SVG Viewer</td><td>SVG预览</td></tr><tr><td>TODO Hignlight</td><td>Todo高亮</td></tr><tr><td>TODO Parser</td><td>Todo管理</td></tr><tr><td>TSLint</td><td>ts语法纠错</td></tr><tr><td>Typings Installer</td><td>增加扩展自动补全功能</td></tr><tr><td>TypeScript Importer</td><td>自动搜索工作区文件中的TypeScript定义，并将所有已知符号作为完成项，以允许代码完成</td></tr><tr><td>Version Lens</td><td>依赖包文件显示模块当前版本和最新版本</td></tr><tr><td>Vetur</td><td>语法高亮、智能感知、Emmet等</td></tr><tr><td>Vetur E</td><td>配合TouchUI工具</td></tr><tr><td>View In Browser</td><td>内置浏览器预览</td></tr><tr><td>vscode-faker</td><td>生成假数据,地址,电话,图片等等</td></tr><tr><td>vscode-fileheader</td><td>在文件前边添加注释，作者、日期等</td></tr><tr><td>vscode-icons</td><td>文件图标主题</td></tr><tr><td>Vue 2 Snippets</td><td>Vue2.x 片段补全工具</td></tr><tr><td>Vue Peek</td><td>Vue里的路径跳转</td></tr><tr><td>Vue TypeScript Snippets</td><td>Vue里的TS代码段提示</td></tr><tr><td>wpy-beautify</td><td>wepy单文件格式化</td></tr><tr><td></td></tr></tbody></table><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><blockquote><p>在不同机器上，保持插件自动上传下载。需要与github配合，详情可以看[<a href="https://www.cnblogs.com/ashidamana/p/6761085.html">vscode同步设置&amp;扩展插件</a>]</p></blockquote></script></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;强制&quot;&gt;&lt;a href=&quot;#强制&quot; class=&quot;headerlink&quot; title=&quot;强制&quot;&gt;&lt;/a&gt;强制&lt;/h2&gt;&lt;h4 id=&quot;1-组件名为多个单词驼峰形式&quot;&gt;&lt;a href=&quot;#1-组件名为多个单词驼峰形式&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>打造一个舒心的vue开发工作流</title>
    <link href="https://kpeng.wang/2018/08/17/%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E8%88%92%E5%BF%83%E7%9A%84vue%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://kpeng.wang/2018/08/17/打造一个舒心的vue开发工作流/</id>
    <published>2018-08-17T09:33:50.000Z</published>
    <updated>2018-08-17T09:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><ul><li><strong>vue-cli3.0</strong></li></ul><h2 id="注入插件"><a href="#注入插件" class="headerlink" title="注入插件"></a>注入插件</h2><ul><li><strong>PostCss</strong> =&gt; <em>支持px单位自动换算</em></li><li><strong>Stylus + Stylus-loader</strong> =&gt; <em>支持Stylus语法糖</em></li><li><strong>VConsole</strong> =&gt; <em>支持移动端调试控制台</em></li><li><strong>Lodash</strong>  =&gt; <em>支持Js工具库</em></li><li><strong>NProgress</strong> =&gt; <em>支持页面跳转顶部loading</em></li><li><strong>axios</strong>  =&gt; <em>支持ajax数据请求和数据劫持</em></li><li><strong>mock.js</strong> =&gt; <em>支持前端mock静态数据</em></li><li><strong>.editorConfig</strong> =&gt; <em>支持编辑器统一代码格式化</em></li><li><strong>Vue-Meta</strong>  =&gt; <em>支持SPA下单独设置页面title以及元信息</em></li><li><strong>husky + lint-staged</strong>  =&gt; <em>支持Git钩子验证</em></li><li><strong>vue-lazyload</strong>  =&gt; <em>支持图片懒加载</em></li><li><strong>vue-lazy-component</strong>  =&gt; <em>支持模版懒加载，可做骨架屏优化</em></li><li><strong>vuex</strong>  =&gt; <em>支持状态管理器</em></li><li><strong>vuex-persistedstate</strong>  =&gt; <em>支持数据状态持久化</em></li><li><strong>vue-router</strong> =&gt; <em>支持路由跳转管理</em></li><li><strong>vuex-router-sync</strong> =&gt; <em>支持router的状态&lt;path,query和params&gt;存入vuex的state中</em></li><li>…</li></ul><h2 id="UI库"><a href="#UI库" class="headerlink" title="UI库"></a>UI库</h2><ul><li><strong>cube-ui</strong>  </li></ul><h2 id="Webpack-优化"><a href="#Webpack-优化" class="headerlink" title="Webpack 优化"></a>Webpack 优化</h2><ul><li><strong>Happypack</strong>  =&gt; <em>多进程打包</em></li><li><strong>webpack-parallel-unglify-plugin</strong> =&gt; <em>利用缓存快速压缩</em></li><li>…</li></ul><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li><strong>vue-i18n</strong> =&gt; <em>多语言配置解决方案</em></li><li><strong>vue-class-component</strong> =&gt; <em>以class的模式写Vue</em></li><li><strong>vuex-class-</strong> =&gt; <em>装饰器语法写Vuex</em></li><li><strong>vue-property-decorator</strong>  =&gt; <em>装饰器语法写钩子函数</em></li><li><strong>SSR</strong>  =&gt; <em>支持服务端渲染</em></li><li><strong>Koa2/egg</strong>  =&gt; <em>支持中间层</em></li><li>…</li></ul><hr><h1 id="Base-脚手架"><a href="#Base-脚手架" class="headerlink" title="Base 脚手架"></a>Base 脚手架</h1><blockquote><p>主要基于vue-cli 3.0 版本做了一些提高团队生产力和开发效率的事情。推荐阅读<a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">vue-cli官方文档</a>。</p></blockquote><hr><h1 id="插件说明"><a href="#插件说明" class="headerlink" title="插件说明"></a>插件说明</h1><h2 id="PostCss"><a href="#PostCss" class="headerlink" title="PostCss"></a>PostCss</h2><blockquote><p>这里有一个坑需要注意一下,踩了一坑，由于<code>postcss-px-to-viewport</code>并没有<code>exclude</code>配置项，所以会把<code>node_modules</code>里的ui库文件的css也包含进去进行转换，控制台会出现warning，所以需要做一些必要的处理。</p></blockquote><p><img src="https://github.com/kpengWang/Blog-images-storage/blob/master/2018-08-17/1.png?raw=true" alt="warning"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 此段代码在依赖包postcss-px-to-viewport/index.js里 大约第30行</span></span><br><span class="line">...</span><br><span class="line">css.walkDecls(<span class="function"><span class="keyword">function</span> (<span class="params">decl, i</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options.exclude) &#123; <span class="comment">// 添加对exclude选项的处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(options.exclude) !== <span class="string">'[object RegExp]'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'options.exclude should be RegExp!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (decl.source.input.file.match(options.exclude) !== <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后就在<code>.postcssrc</code>配置文件里添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="string">"postcss-px-to-viewport"</span>:&#123;</span><br><span class="line">     ...</span><br><span class="line">    exclude: <span class="regexp">/(\/|\\)(node_modules)(\/|\\)/</span>  <span class="comment">// 忽略node_modules</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Stylus-Stylus-loader"><a href="#Stylus-Stylus-loader" class="headerlink" title="Stylus + Stylus-loader"></a>Stylus + Stylus-loader</h2><blockquote><p>推荐使用Stylus，语法简练。<br>具体语法可参考<a href="https://devhints.io/stylus" target="_blank" rel="noopener">Stylus cheatsheet</a></p></blockquote><h2 id="VConsole"><a href="#VConsole" class="headerlink" title="VConsole"></a>VConsole</h2><blockquote><p>真机调试，在<code>main.js</code>里已配置。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开发环境开启vConsole</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vConsole = <span class="keyword">new</span> VConsole()</span><br><span class="line">  <span class="built_in">console</span>.log(vConsole.version)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lodash"><a href="#Lodash" class="headerlink" title="Lodash"></a>Lodash</h2><blockquote><p>在<code>main.js</code>里注入到Vue的原型上，通过<code>this._</code>来调用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._ = lodash</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Example</span></span><br><span class="line"><span class="keyword">this</span>._.chunk([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>], <span class="number">2</span>);</span><br><span class="line"><span class="comment">// =&gt; [['a', 'b'], ['c', 'd']]</span></span><br></pre></td></tr></table></figure><p>其它用法请浏览<br><a href="https://www.lodashjs.com/docs/4.17.5.html" target="_blank" rel="noopener">lodash文档</a>。</p><h2 id="NProgress"><a href="#NProgress" class="headerlink" title="NProgress"></a>NProgress</h2><blockquote><p>在<code>main.js</code>里引入样式文件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'nprogress/nprogress.css'</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>router.js</code>的钩子函数里根据不同场景做配置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  判断是否需要登录权限 以及是否登录</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> userinfo = storage.get(<span class="string">'userinfo'</span>)</span><br><span class="line">  <span class="comment">// 判断是否需要登录权限</span></span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">res</span> =&gt;</span> res.meta.requireAuth)) &#123; </span><br><span class="line">    <span class="comment">// 判断是否登录</span></span><br><span class="line">    <span class="keyword">if</span> (userinfo) &#123; </span><br><span class="line">      next()</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 没登录则跳转到登录界面</span></span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      NProgress.start()</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: <span class="string">'/Login'</span>,</span><br><span class="line">        query: &#123; <span class="attr">redirect</span>: to.fullPath &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.afterEach(<span class="function"><span class="params">transition</span> =&gt;</span> &#123;</span><br><span class="line">  NProgress.done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><blockquote><p>axios除了接口请求，主要还做了拦截处理，利于接口数据异常统一管理，相关代码都在<code>src/api</code>文件夹内。</p></blockquote><p>请求拦截的逻辑放在<code>src/api/axios.js</code>里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http请求拦截器&lt;pendding&gt;</span></span><br><span class="line">Axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 以下的判断处理可根据具体需求场景做一些统一操作</span></span><br><span class="line">    <span class="keyword">const</span> token = cookie.get(<span class="string">'token'</span>)  </span><br><span class="line">    <span class="comment">// 判断是否存在token，即判断用户是否登录</span></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      cookie.set(<span class="string">'token'</span>, token, <span class="number">1</span> / <span class="number">12</span>) <span class="comment">// 用户每次操作，都将cookie设置成2小时</span></span><br><span class="line">      config.headers.Authorization = token <span class="comment">// 每个http header都加上token</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line"> error =&gt; &#123;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>所有的接口请求统一放在<code>src/api/index.js</code>里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首页信息</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getHome = <span class="function">(<span class="params">params</span>) =&gt;</span> axios.get(HOST + <span class="string">'home'</span>, params)</span><br></pre></td></tr></table></figure><p>然后在<code>.vue</code>文件内使用如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/ecmascript-6"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; getHome &#125; <span class="keyword">from</span> <span class="string">'@/api'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// do something....</span></span><br><span class="line">    methods:&#123;</span><br><span class="line">        <span class="comment">// 获取数据，私有方法尽量使用 _ 前缀</span></span><br><span class="line">        <span class="keyword">async</span> _fetchData() &#123;</span><br><span class="line">          <span class="keyword">const</span> res = <span class="keyword">await</span> getHome()</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = res.data</span><br><span class="line">            <span class="keyword">this</span>.slideImgs = data.slideImgs</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'获取数据错误'</span>, err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="keyword">this</span>._fetchData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="mock-js"><a href="#mock-js" class="headerlink" title="mock.js"></a>mock.js</h2><blockquote><p>很多时候我们前端来定接口数据结构，<code>easy-mock</code>等在线工具也好用，但是经常出现不稳定，网址频繁挂掉。这里的moack主要引入<a href="https://www.npmjs.com/package/axios-mock-adapter" target="_blank" rel="noopener">axios-mock-adapter</a>，一样配合axios来做了拦截处理。mock的语法请参考官方文档<a href="https://github.com/nuysoft/Mock/wiki" target="_blank" rel="noopener">Mock</a>。</p></blockquote><p>所有的mock数据接口每条单独一份放在<code>src/mock/data</code>文件夹下，数据对象使用<code>common.js</code>语法暴露出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  code: <span class="number">10000</span>,</span><br><span class="line">  message: <span class="string">'success'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="string">'list|100'</span>: [&#123;</span><br><span class="line">      <span class="string">'id|+1'</span>: <span class="number">1</span>,</span><br><span class="line">      userName: <span class="string">'@cname()'</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>src/mock/index.js</code>里封装了一个<code>CreateInterface</code>类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.SUCCESS_STATUS = <span class="number">200</span> <span class="comment">// 成功状态</span></span><br><span class="line">    <span class="keyword">this</span>.FAIL_STATUS = <span class="number">500</span> <span class="comment">// 失败状态</span></span><br><span class="line">    <span class="keyword">this</span>.mocker = <span class="keyword">new</span> MockAdapter(Axios)</span><br><span class="line">    <span class="comment">// mock接口列表，需要手动添加</span></span><br><span class="line">    <span class="keyword">this</span>.interfaces = [</span><br><span class="line">      <span class="string">'users'</span>,</span><br><span class="line">      <span class="comment">// more interface...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; interfaces, mocker, SUCCESS_STATUS &#125; = <span class="keyword">this</span></span><br><span class="line">    interfaces.forEach(<span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">      mocker.onGet(filename).reply(<span class="function">(<span class="params">config</span>) =&gt;</span> [SUCCESS_STATUS, Mock.mock(<span class="built_in">require</span>(<span class="string">`./data/<span class="subst">$&#123;filename&#125;</span>`</span>))])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="editorConfig"><a href="#editorConfig" class="headerlink" title=".editorConfig"></a>.editorConfig</h2><blockquote><p>可操作的配置虽然不多，但是能覆盖大部分情况。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="literal">true</span> <span class="comment">#表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件</span></span><br><span class="line"></span><br><span class="line">[*] <span class="comment"># 对所有文件生效</span></span><br><span class="line">charset = utf-8</span><br><span class="line">indent_style = space <span class="comment">#tab为hard-tabs，space为soft-tabs</span></span><br><span class="line">indent_size = 2 <span class="comment">#设置整数表示规定每级缩进的列数和soft-tabs的宽度</span></span><br><span class="line">end_of_line = lf <span class="comment">#定义换行符，支持lf、cr和crlf</span></span><br><span class="line">insert_final_newline = <span class="literal">true</span> <span class="comment">#设为true表明使文件以一个空白行结尾，false反之</span></span><br><span class="line">trim_trailing_whitespace = <span class="literal">true</span> <span class="comment">#设为true表示会除去换行行首的任意空白字符，false反之</span></span><br></pre></td></tr></table></figure><p> 编辑器一样还是推荐使用VsCode，里面有个插件支持可以安装下。<br><img src="https://github.com/kpengWang/Blog-images-storage/blob/master/2018-08-17/2.png?raw=true" alt="editorConfig for VsCode"></p><h2 id="Vue-Meta"><a href="#Vue-Meta" class="headerlink" title="Vue-Meta"></a>Vue-Meta</h2><blockquote><p>视情况使用，一般在PC端应用的相对比较多。在<code>main.js</code>里引入后全局注册。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueMeta <span class="keyword">from</span> <span class="string">'vue-meta'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独设置页面的title和meta信息</span></span><br><span class="line">Vue.use(VueMeta)</span><br></pre></td></tr></table></figure></p></blockquote><p>具体在vue文件内使用方法如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      pageTitle: <span class="string">'个人中心'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  metaInfo() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: <span class="keyword">this</span>.pageTitle,</span><br><span class="line">      titleTemplate: <span class="string">'%s - Test'</span>,</span><br><span class="line">      script: [&#123; <span class="attr">innerHTML</span>: <span class="string">'console.log("Hey!~~!")'</span>, <span class="attr">type</span>: <span class="string">'text/javascript'</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">![title](https:<span class="comment">//github.com/kpengWang/Blog-images-storage/blob/master/2018-08-17/3.png?raw=true)</span></span><br><span class="line">![控制台<span class="built_in">console</span>](https:<span class="comment">//github.com/kpengWang/Blog-images-storage/blob/master/2018-08-17/4.png?raw=true)</span></span><br></pre></td></tr></table></figure></p><h2 id="husky-lint-staged"><a href="#husky-lint-staged" class="headerlink" title="husky + lint-staged"></a>husky + lint-staged</h2><blockquote><p>主要是在把 Lint 挪到本地，并且每次提交只检查本次提交所修改的文件，使用 <code>git commit -a</code>，或者先 <code>git add</code>然后 <code>git commit</code> 的时候，你的修改代码都会经过待提交区。</p></blockquote><p>主要配置在<code>package.js</code>配置文件里.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"script"</span>:&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="string">"precommit"</span>: <span class="string">"lint-staged"</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="string">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="string">"src/**/*.&#123;js,ts&#125;"</span>: [</span><br><span class="line">      <span class="string">"standard --write"</span>,</span><br><span class="line">      <span class="string">"eslint --fix"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="vue-lazyload"><a href="#vue-lazyload" class="headerlink" title="vue-lazyload"></a>vue-lazyload</h2><blockquote><p>它其实就是注册一个全局指令，然后使用一个默认图片。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// do something </span></span><br><span class="line">Vue.use(VueLazyLoad, &#123;</span><br><span class="line">  loading: <span class="built_in">require</span>(<span class="string">'./common/image/default.png'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// do something</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"img"</span>  <span class="attr">v-lazy</span>=<span class="string">"item.url"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vue-lazy-component"><a href="#vue-lazy-component" class="headerlink" title="vue-lazy-component"></a>vue-lazy-component</h2><blockquote><p>引用这个插件具体解决做Seketon骨架屏效果。可配置的参数实用，效果不错。</p></blockquote><ul><li>支持 组件可见或即将可见时懒加载</li><li>支持 组件延时加载</li><li>支持 加载真实组件前展示骨架组件，提高用户体验</li><li>支持 真实组件代码分包异步加载</li></ul><ul><li>具体文档参考<a href="https://www.npmjs.com/package/@xunlei/vue-lazy-component" target="_blank" rel="noopener">@xunlei/vue-lazy-component</a>。</li><li><a href="https://xunleif2e.github.io/vue-lazy-component/demo/dist/index.html#/" target="_blank" rel="noopener">在线Demo效果</a></li></ul><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><blockquote><p>推荐直接阅读<a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">vuex官方文档</a>。项目结构一样是使用的官方推荐的。</p></blockquote><h2 id="vuex-persistedstate"><a href="#vuex-persistedstate" class="headerlink" title="vuex-persistedstate"></a>vuex-persistedstate</h2><blockquote><p> 数据持久化解决方案,主要使用场景是，页面刷新时当前页面的状态仍然可以保持。</p></blockquote><ul><li>当vuex状态发生改变时，自动同步保存到<code>localStorage</code>。</li><li>当重新加载页面vuex初始化时，自动将<code>localStorage</code>存储的数据作为初始状态加载。</li></ul><p>在<code>src/store/index.js</code>内引入插件并使用，无需其它操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">'vuex-persistedstate'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> storage <span class="keyword">from</span> <span class="string">'@/utils/storage'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  strict: debug,</span><br><span class="line">  <span class="comment">// 状态持久化</span></span><br><span class="line">  plugins: [</span><br><span class="line">    createPersistedState(&#123;</span><br><span class="line">      storage: &#123;</span><br><span class="line">        getItem: <span class="function"><span class="params">key</span> =&gt;</span> storage.get(key),</span><br><span class="line">        setItem: <span class="function">(<span class="params">key, value</span>) =&gt;</span> storage.set(key, value),</span><br><span class="line">        removeItem: <span class="function"><span class="params">key</span> =&gt;</span> storage.remove(key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="vuex-router-sync"><a href="#vuex-router-sync" class="headerlink" title="vuex-router-sync"></a>vuex-router-sync</h2><blockquote><p>主要是router的状态&lt;path,query和params&gt;存入vuex的state中；<br>使用方式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.state.route.path   <span class="comment">// current path (string)</span></span><br><span class="line">store.state.route.params <span class="comment">// current params (object)</span></span><br><span class="line">store.state.route.query  <span class="comment">// current query (object)</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><h1 id="UI库-1"><a href="#UI库-1" class="headerlink" title="UI库"></a>UI库</h1><h2 id="Cube-UI"><a href="#Cube-UI" class="headerlink" title="Cube-UI"></a>Cube-UI</h2><blockquote><p>cube-ui 是基于 Vue.js 实现的精致移动端组件库。推荐阅读<a href="https://didi.github.io/cube-ui/#/zh-CN/docs/introduction" target="_blank" rel="noopener">官方文档</a>。</p><ul><li>PC门户网站：使用<a href="https://muse-ui.org/#/zh-CN/installation" target="_blank" rel="noopener">Muse-UI</a></li><li>PC后台CMS：使用<a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/" target="_blank" rel="noopener">vue-element-admin</a>。</li></ul></blockquote><p>常用的组件我们可以直接在<code>main.js</code>里全局注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">  Style,  <span class="comment">// 引入 Style 加载基础样式</span></span><br><span class="line">  Loading,</span><br><span class="line">  Button,</span><br><span class="line">  Dialog,</span><br><span class="line">  Toast,</span><br><span class="line">  Scroll</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'cube-ui'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Scroll)</span><br><span class="line">Vue.use(Loading)</span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Dialog)</span><br><span class="line">Vue.use(Toast)</span><br></pre></td></tr></table></figure><hr><h1 id="Webpack优化"><a href="#Webpack优化" class="headerlink" title="Webpack优化"></a>Webpack优化</h1><blockquote><p>与2.x相同，在根目录下新建了<code>build</code>文件夹。所有可以优化webpack相关的代码逻辑放入这里，仍然通过node环境变量来使用<code>webpack-merge</code>做逻辑合并。</p></blockquote><ul><li><strong>webpack.base.conf.js</strong> 共用的配置文件</li><li><strong>webpack.dev.conf.js</strong>  走开发环境的配置文件</li><li><strong>webpack.prod.conf.js</strong>  走生产环境的配置文件</li><li><strong>config.js</strong>           配置参数</li></ul><h2 id="Happypack"><a href="#Happypack" class="headerlink" title="Happypack"></a>Happypack</h2><blockquote><p>通过多进程模型，来加速代码构建，代码在<code>webpack.prod.conf.js</code>文件中，主要使用了Happypack的<code>ThreadPool</code>方法，HappyThreadPool(“进程池”) 对象来管理生成的子进程对象。利用缓存来使得rebuild 更快。</p></blockquote><blockquote><p>推荐阅读<a href="http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/" target="_blank" rel="noopener">happypack 原理解析</a>。</p></blockquote><p>具体操作方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.conf.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> OS = <span class="built_in">require</span>(<span class="string">'os'</span>)</span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123; <span class="attr">size</span>: OS.cpus().length &#125;)</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">          id: <span class="string">'happybabel'</span>,</span><br><span class="line">          loaders: [<span class="string">'babel-loader'</span>],</span><br><span class="line">          threadPool: happyThreadPool,</span><br><span class="line">          cache: <span class="literal">true</span>,</span><br><span class="line">          verbose: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-parallel-unglify-plugin"><a href="#webpack-parallel-unglify-plugin" class="headerlink" title="webpack-parallel-unglify-plugin"></a>webpack-parallel-unglify-plugin</h2><blockquote><p>webpack提供的UglifyJS插件由于采用单线程压缩，速度很慢； 使用<code>webpack-parallel-unglify-plugin</code>可以并行运行UglifyJS插件，这可以有效减少构建时间多线程压缩js。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.conf.js</span></span><br><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>)</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">          cacheDir: <span class="string">'.cache/'</span>,</span><br><span class="line">          sourceMap: <span class="literal">false</span>,</span><br><span class="line">          uglifyJS: &#123;</span><br><span class="line">            output: &#123; <span class="attr">comments</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">            compress: &#123; <span class="attr">warnings</span>: <span class="literal">false</span> &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;h2 id=&quot;Base&quot;&gt;&lt;a href=&quot;#Base&quot; class=&quot;headerlink&quot; title=&quot;Base&quot;&gt;&lt;/a&gt;Base&lt;/h
      
    
    </summary>
    
    
      <category term="工作流" scheme="https://kpeng.wang/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
      <category term="Vue" scheme="https://kpeng.wang/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise的前世</title>
    <link href="https://kpeng.wang/2018/06/08/Promise%E7%9A%84%E5%89%8D%E4%B8%96/"/>
    <id>https://kpeng.wang/2018/06/08/Promise的前世/</id>
    <published>2018-06-07T16:59:20.000Z</published>
    <updated>2018-07-07T17:04:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Promise这个新的构造函数已经是个老生常谈的问题，今天在这里再次提到它，是想回顾一下Jquery里的<code>$.ajax()</code>方法。</p><hr><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax()"></a>Ajax()</h2><p>从蛮荒时代过来的老司机们，请求接口很多都是拿jquery一顿撸，返回数据无非都是拿jsonp格式能覆盖很多业务场景。至于其它的跨域解决方案今天不展开讨论。</p><p>ajax方法其实是在<strong>jquery1.5</strong>版本之后改动非常之大，在<strong>1.5之前</strong>，返回结果是一个XHR对象实例，而在<strong>1.5之后</strong>它返回的就是一个基本对象，差异很大。<br><img src="https://p.qlogo.cn/qqmail_head/Q3auHgzwzM6NZ3fLpAqBLovOO4mndJsCL7icnOibzBEcuCL6OZXt7e4qyfSZsicqJpSNBopTsKAWt0/0" alt="1.5版本之前"></p><p><img src="https://p.qlogo.cn/qqmail_head/Q3auHgzwzM6NZ3fLpAqBLovOO4mndJsCL7icnOibzBEcuU8WAYbBBLwCCjez1WcibWCETHhdYR2ic9k/0" alt="1.5版本之后"></p><h2 id="jquery-1-5之前"><a href="#jquery-1-5之前" class="headerlink" title="jquery-1.5之前"></a>jquery-1.5之前</h2><p>在<strong>1.5之前</strong>一般都是这样来使用ajax()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajax = $.ajax(&#123;</span><br><span class="line">  url: <span class="string">'../data.json'</span>,</span><br><span class="line">  success() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'ok 1'</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'ok 2'</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'ok 3'</span>)</span><br><span class="line">   .....</span><br><span class="line">  &#125;,</span><br><span class="line">  error() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err 1'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err 2'</span>)</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这样写弊端很明显，尤其是不利于方法的封装以及后期维护和扩展，如果需求有变更，首先就需要在原来的<code>success</code>或者<code>error</code>方法里继续操作；因为代码耦合，测试同学又得把之前无功能更改的地方测一遍，这样回归bug或者提测的话，也会让后面测试的同学增加额外的工作量。</p><h2 id="jquery-1-5之后"><a href="#jquery-1-5之后" class="headerlink" title="jquery-1.5之后"></a>jquery-1.5之后</h2><p>如上图的console结果，在<strong>1.5之后</strong>，完全可以链式操作，这样才真正符合jquery的标准。</p><h3 id="使用done-，fail-方法"><a href="#使用done-，fail-方法" class="headerlink" title="使用done()，fail()方法"></a>使用done()，fail()方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajax = $.ajax(<span class="string">'./data.json'</span>)</span><br><span class="line"></span><br><span class="line">ajax.done(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 请求成功</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ok 1'</span>) </span><br><span class="line">&#125;).fail(<span class="function"><span class="params">()</span> =&gt;</span> &#123;   <span class="comment">// 请求失败</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'err 1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用then-方法"><a href="#使用then-方法" class="headerlink" title="使用then()方法"></a>使用then()方法</h3><p><code>then(resolve,reject)</code>方法与构造函数<code>new Promise()</code>的参数作用基本一致，一参表示返回成功，二参代表返回失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ajax = $.ajax(<span class="string">'./data.json'</span>)</span><br><span class="line"> </span><br><span class="line">ajax.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="comment">// 请求成功</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ok 1'</span>)</span><br><span class="line">&#125;, () =&gt; &#123; <span class="comment">// 请求失败</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'err 1'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Deferred"><a href="#Deferred" class="headerlink" title="$.Deferred()"></a>$.Deferred()</h3><blockquote><p><code>$.Deferred()</code>是一个延迟对象，在<strong>jQuery的1.5</strong>引入，是通过调用<code>$.Deferred()</code>方法创建一个可链式调用的工具对象。 它可以注册多个回调到回调队列， 调用回调队列，准备代替任何同步或异步函数的成功或失败状态。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const waitHandle = () =&gt; &#123;</span><br><span class="line">  const def = $.Deferred()</span><br><span class="line">  const wait = (def) =&gt; &#123;</span><br><span class="line">    const task = () =&gt; &#123;</span><br><span class="line">      console.log(&apos;执行完成&apos;)</span><br><span class="line">      def.resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(task, 1000)</span><br><span class="line">    </span><br><span class="line">    // 重点！ 这里返回一个promise，防止手动触发reject()方法，不然会阻塞进程</span><br><span class="line">    return def.promise()</span><br><span class="line">  &#125;</span><br><span class="line">  return wait(def)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let wait = waitHandle()</span><br><span class="line"></span><br><span class="line">$.when(wait)</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;ok 1&apos;)</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;ok 2&apos;)</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;ok 3&apos;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="业务代码封装"><a href="#业务代码封装" class="headerlink" title="业务代码封装"></a>业务代码封装</h2><p>针对仅get,post请求的封装<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> def = $.Deferred()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> post = <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">   $.post(url, data).then(<span class="function"><span class="params">data</span> =&gt;</span> def.resolve(data))</span><br><span class="line">   <span class="keyword">return</span> def</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> get= <span class="function">(<span class="params">url, data</span>) =&gt;</span> &#123;</span><br><span class="line">   $.get(url, data).then(<span class="function"><span class="params">data</span> =&gt;</span> def.resolve(data))</span><br><span class="line">   <span class="keyword">return</span> def</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用jsonp的话，需要额外再封装一层，方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export const request = (url, method, data) =&gt; &#123;</span><br><span class="line">  const baseUrl = &apos;&apos;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: baseUrl + url,</span><br><span class="line">    type: method,</span><br><span class="line">    dataType: &quot;jsonp&quot;,</span><br><span class="line">    jsonp: &quot;callback&quot;,</span><br><span class="line">    data</span><br><span class="line">  &#125;).then(res =&gt; &#123;</span><br><span class="line">    res.code === 10000 ? def.resolve(res) : def.reject(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  return def</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const get = (url, data) =&gt; request(url, &apos;GET&apos;, data)</span><br><span class="line"></span><br><span class="line">export const post = (url, data) =&gt; request(url, &apos;POST&apos;, data)</span><br></pre></td></tr></table></figure></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，在<strong>1.5之后</strong>，jquery的变化以下几点</p><ul><li>无法改变JS异步和单线程本质</li><li>只能从写法上杜绝callback的形式</li><li>它是一种语法糖形式，但是解耦的代码</li><li>很好的体现了<strong>开放封闭原则</strong>（对扩展开发，对修改封闭）</li><li>Deferred的API可分为两类，用意不同，不可混用！<ul><li>第一类，手动触发：<code>def.resolve()</code>,<code>def.reject()</code></li><li>第二类，自主监听：<code>def.then()</code>,<code>def.done()</code>,<code>def.fail()</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Promise这个新的构造函数已经是个老生常谈的问题，今天在这里再次提到它，是想回顾一下Jquery里的&lt;code&gt;$.ajax()&lt;/code&gt;方法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="jquery" scheme="https://kpeng.wang/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>Promise.all了解一下</title>
    <link href="https://kpeng.wang/2018/06/04/Promise-all%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/"/>
    <id>https://kpeng.wang/2018/06/04/Promise-all了解一下/</id>
    <published>2018-06-03T16:15:15.000Z</published>
    <updated>2018-07-07T17:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>在有些业务需求下，要一次返回多个不同请求结果，分别两个场景：</p><ul><li>同一条请求不同，参数不同</li><li>多个不同请求，参数相同</li></ul><h2 id="参数不同，请求相同"><a href="#参数不同，请求相同" class="headerlink" title="参数不同，请求相同"></a>参数不同，请求相同</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let types = [0, 1, 2]</span><br><span class="line">function toSort(obj) &#123; // 转换同步</span><br><span class="line">    params.player_type = obj</span><br><span class="line">    return api.getPlayerStayRole(params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Promise.all(playerTypes.map(item =&gt; toSort(item))).then(res =&gt; &#123;</span><br><span class="line">      // do something</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="参数相同，请求不同"><a href="#参数相同，请求不同" class="headerlink" title="参数相同，请求不同"></a>参数相同，请求不同</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let conmmonParams = &#123; app_id: &apos;all&apos;, project_id: 10000001 &#125; //公共参数</span><br><span class="line">let types = [0, 1, 2]</span><br><span class="line">let content = &apos;&apos;</span><br><span class="line"></span><br><span class="line">function toSort(obj) &#123;</span><br><span class="line">    switch (obj.type) &#123;</span><br><span class="line">        case 1: // 区服</span><br><span class="line">            return api.filterServer(conmmonParams)</span><br><span class="line">            break</span><br><span class="line">        case 2: // 常规渠道 </span><br><span class="line">            return api.filterChannel(conmmonParams)</span><br><span class="line">            break</span><br><span class="line">        case 3: // 广告渠道</span><br><span class="line">            return api.filterAdChannel(conmmonParams)</span><br><span class="line">            break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all(types.map(item =&gt; toSort(&#123; type: item &#125;))).then(resArr =&gt; &#123;</span><br><span class="line">    // 需要手动拼接的参数</span><br><span class="line">    const staticParam = [</span><br><span class="line">        &#123; title: &apos;aaa&apos;, type: &apos;server&apos; &#125;,</span><br><span class="line">        &#123; title: &apos;bbb&apos;, type: &apos;channel&apos; &#125;,</span><br><span class="line">        &#123; title: &apos;ccc&apos;, type: &apos;ad_channel&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    // 将静态字段title和type 并入接口数据中</span><br><span class="line">    filterType.forEach((k, j) =&gt; resArr[j] = Object.assign(&#123;&#125;,resArr[j], staticParam[k]))</span><br><span class="line"></span><br><span class="line">    // 将传入的不同类型</span><br><span class="line">    resArr.forEach(res =&gt; content.push(res))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在有些业务需求下，要一次返回多个不同请求结果，分别两个场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一条请求不同，参数不同&lt;/li&gt;
&lt;li&gt;多个不同请求，参数相同&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参数不同，请求相同&quot;&gt;&lt;a href=&quot;#参数不同，请求相同&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://kpeng.wang/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Ⅳ--实现Virtual DOM下的一个VNode节点</title>
    <link href="https://kpeng.wang/2018/05/22/%E2%85%A3-%E5%AE%9E%E7%8E%B0Virtual-DOM%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AAVNode%E8%8A%82%E7%82%B9/"/>
    <id>https://kpeng.wang/2018/05/22/Ⅳ-实现Virtual-DOM下的一个VNode节点/</id>
    <published>2018-05-22T15:53:00.000Z</published>
    <updated>2018-05-22T15:57:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是VNode"><a href="#什么是VNode" class="headerlink" title="什么是VNode?"></a>什么是VNode?</h3><p>我们知道，render function会被转化成VNode节点。Virtual DOM其实就是一颗以JavaScript对象（VNode节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。最终可以通过一些列操作使这棵树映射到真实环境上。由于Virtual DOM是以JavaScript对象为基础而不依赖真实环境平台，所以使它具有了跨平台的能力，比如说浏览器、Weex、Node等。</p><hr><h3 id="实现一个VNode"><a href="#实现一个VNode" class="headerlink" title="实现一个VNode"></a>实现一个VNode</h3><p>VNode归根结底就是一个JavaScript对象，只要这个类的一些属性可以正确直观地描述清楚当前节点的信息即可。先来实现一个简单的<code>Vnode</code>类，加入一些基本属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vnode</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(tag,data,children,text,elem)&#123;</span><br><span class="line">        <span class="comment">// 当前节点的标签名</span></span><br><span class="line">        <span class="keyword">this</span>.tag = tag</span><br><span class="line">        <span class="comment">// 当前节点的一些数据信息</span></span><br><span class="line">        <span class="keyword">this</span>.data = data</span><br><span class="line">        <span class="comment">// 当前节点的子节点，是数组形式</span></span><br><span class="line">        <span class="keyword">this</span>.children = children</span><br><span class="line">        <span class="comment">// 当前节点的文本</span></span><br><span class="line">        <span class="keyword">this</span>.text = text</span><br><span class="line">        <span class="comment">// 当前虚拟节点对应的真实dom节点</span></span><br><span class="line">        <span class="keyword">this</span>.elem = elem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有这么一个组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"demo"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>&gt;</span></span><br><span class="line">        This is a span</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用JavaScript代码的展现形式就是如下这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(</span><br><span class="line">        <span class="string">'span'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 指令集合数组</span></span><br><span class="line">            directives:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 'v-show'指令</span></span><br><span class="line">                    rawName: <span class="string">'v-show'</span>,</span><br><span class="line">                    expression:<span class="string">'isShow'</span>,</span><br><span class="line">                    name:<span class="string">'show'</span>,</span><br><span class="line">                    value:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// 静态class</span></span><br><span class="line">            staticClass:<span class="string">'demo'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="string">'This is a span'</span>)]</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看下VNode以后的情况：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">'span'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="comment">// 指令集合数组</span></span><br><span class="line">        directives:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 'v-show'指令</span></span><br><span class="line">                rawName: <span class="string">'v-show'</span>,</span><br><span class="line">                expression: <span class="string">'isShow'</span>,</span><br><span class="line">                name: <span class="string">'show'</span>,</span><br><span class="line">                value: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 静态class</span></span><br><span class="line">        staticClass: <span class="string">'demo'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    text: <span class="literal">undefined</span>,</span><br><span class="line">    children:[</span><br><span class="line">        <span class="comment">// 子节点是一个文本VNode节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="literal">undefined</span>,</span><br><span class="line">            data: <span class="literal">undefined</span>,</span><br><span class="line">            text: <span class="string">'This is a span'</span>,</span><br><span class="line">            children: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="进一步封装VNode"><a href="#进一步封装VNode" class="headerlink" title="进一步封装VNode"></a>进一步封装VNode</h3><p> 通过进一步封装,可以实现一些常用的VNode方法：</p><ul><li>创建一个空node节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEmptyVNode</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> VNode()</span><br><span class="line">    node.text = <span class="string">''</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个文本节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="built_in">String</span>(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>克隆一个VNode节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneVNode</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cloneVnode = <span class="keyword">new</span> VNode(</span><br><span class="line">     node.tag,</span><br><span class="line">     node.data,</span><br><span class="line">     node.children,</span><br><span class="line">     node.text,</span><br><span class="line">     node.elem</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> cloneVnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>…<br>…<br>总之来讲，VNode其实就是一个JavaScript对象，用JavaScript对象的属性来描述当前节点的一些状态，用VNode节点的形式来模拟一颗Virtual DOM树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是VNode&quot;&gt;&lt;a href=&quot;#什么是VNode&quot; class=&quot;headerlink&quot; title=&quot;什么是VNode?&quot;&gt;&lt;/a&gt;什么是VNode?&lt;/h3&gt;&lt;p&gt;我们知道，render function会被转化成VNode节点。Virtual DOM
      
    
    </summary>
    
    
      <category term="vue" scheme="https://kpeng.wang/tags/vue/"/>
    
      <category term="vue源码解读" scheme="https://kpeng.wang/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Ⅲ--响应式系统的依赖收集追踪原理</title>
    <link href="https://kpeng.wang/2018/05/20/%E2%85%A2-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86/"/>
    <id>https://kpeng.wang/2018/05/20/Ⅲ-响应式系统的依赖收集追踪原理/</id>
    <published>2018-05-20T15:28:28.000Z</published>
    <updated>2018-05-20T15:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么要做依赖收集？"><a href="#为什么要做依赖收集？" class="headerlink" title="为什么要做依赖收集？"></a>为什么要做依赖收集？</h3><p>先举个例子🌰，现在有这么一个Vue对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">    <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;&#123;&#123;text2&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        text1:<span class="string">'text1'</span>,</span><br><span class="line">        text1:<span class="string">'text2'</span>,</span><br><span class="line">        text1:<span class="string">'text3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后做了这么一个操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.text3 = <span class="string">'modify text3'</span></span><br></pre></td></tr></table></figure></p><p>这一步修改了<code>data</code>中的<code>text3</code>数据，但是因为视图中并不需要用到<code>text3</code>，所以我们并不需要触发<code>defineReactive</code>方法中的<code>cb</code>函数来更新视图，这里调用<code>cb</code>显然是不合理的。</p><p>再举个例子🌰：</p><p>现在有一个全局对象，我们可能会在多个Vue对象中用到它进行展示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalObj = &#123;</span><br><span class="line">    text1:<span class="string">'text1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> vm1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">    <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    data: globalObj</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> vm2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">    <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;`</span>,</span><br><span class="line">    data: globalObj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这个时候再执行以下操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalObj.text1 = <span class="string">'hello,text1'</span></span><br></pre></td></tr></table></figure></p><p>我们预期结果是要通知<code>vm1</code>和<code>vm2</code>两个实例对象进行视图更新，「依赖收集」会让<code>text1</code>这个数据知道“哦，有两个地方依赖我的数据，我变化的时候需要通知它们！”。</p><p>最终就会形成数据与视图的一种对应关系，如下图：<br><img src="https://user-gold-cdn.xitu.io/2018/1/5/160c4572fdd738f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="依赖收集"></p><hr><h3 id="订阅者模式-Dep"><a href="#订阅者模式-Dep" class="headerlink" title="订阅者模式 Dep"></a>订阅者模式 Dep</h3><p>首先我们来实现一个订阅者Dep,它的主要作用是用来存放<code>Wathcer</code>观察者对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 用来存放 Wathcer对象的数组</span></span><br><span class="line">        <span class="keyword">this</span>.subs=[]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在subs中添加一个Wathcer对象</span></span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知所有的Watcher对象更新视图</span></span><br><span class="line">    notify()&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>)=&gt;</span>&#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了便于理解我们只实现了添加的部分代码，主要是做两件事情：</p><ol><li>用<code>addSub</code>方法可以在目前的<code>Dep</code>对象中添加一个<code>Watcher</code>的订阅操作</li><li>用<code>notify</code>方法通知目前<code>Dep</code>对象的<code>subs</code>中所有的<code>Wathcer</code>对象触发更新操作。</li></ol><hr><h3 id="观察者-Wathcer"><a href="#观察者-Wathcer" class="headerlink" title="观察者 Wathcer"></a>观察者 Wathcer</h3><p>实现观察者Wathcer代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wathcer</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="comment">// 在new一个Wathcer对象时将该对象赋值给Dep.target，在get中用到</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新视图的方法</span></span><br><span class="line">    update()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'视图已更新~'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure></p><hr><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>接下来再修改一下<code>defineReactive</code>以及Vue的构造函数，来完善依赖收集。</p><p>我们在闭包中增加来一个Dep类的对象，用来收集<code>Wather</code>对象。在对象被「读」的时候，会触发<code>reactiveGetter</code>函数把当前的<code>Wathcer</code>对象（存放在<code>Dep.targer</code>中）收集到<code>Dep</code>类中去。之后如果当该对象被「写」的时候，则会触发<code>reactiveSetter</code>方法，通知<code>Dep</code>类调用<code>notify</code>方法触发所有的<code>Wathcer</code>对象的<code>update</code>方法更新视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,prop,val</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Dep类对象</span></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj,prop,&#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// 将Dep.target （即当前的Watcher对象）存入dep的subs中</span></span><br><span class="line">                dep.addSub(Dep.targer)</span><br><span class="line">                <span class="keyword">return</span> val</span><br><span class="line">            &#125;,</span><br><span class="line">            set:<span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(newVal === val) <span class="keyword">return</span></span><br><span class="line">                <span class="comment">// 在set的时候触发dep的notify方法 通知所有的Wathcer对象更新视图</span></span><br><span class="line">                dep.notify()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="keyword">this</span>._data = options.data</span><br><span class="line">        observer(<span class="keyword">this</span>._data)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建一个Watcher观察者对象，这时候Dep.target会指向这个Wathcer对象</span></span><br><span class="line">        <span class="keyword">new</span> Watcher()</span><br><span class="line">        <span class="comment">// 在这里模拟render的过程，为了触发test属性的get函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render~'</span>,<span class="keyword">this</span>._data.test)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>首先在<code>observer</code>的过程中会注册<code>get</code>方法，该方法用来进行 <strong>「依赖收集」</strong>。在它的闭包中会有一个<code>Dep</code>对象，这个对象用来存放<code>Wathcer</code>对象的实例。其实 <strong>「依赖收集」</strong>的过程就是把<code>Wathcer</code>实例存放到对应的<code>Dep</code>对象中去。<code>get</code>方法可以让当前的<code>Wathcer</code>对象（<code>Dep.target</code>）存放（<code>addSub</code>方法）到它的subs中，在数据变化时，<code>set</code>会调用<code>Dep</code>对象的<code>notify</code>方法通知它内部所有的<code>Wathcer</code>对象进行视图更新。</p><p>这是<code>Object.defineProperty</code>的<code>set/get</code>方法处理的事情，那么 <strong>「依赖收集」</strong>的前提条件还有两个：</p><ol><li>触发<code>get</code>方法</li><li>新建一个<code>Wathcer</code>对象</li></ol><p>这个在Vue的构造类中处理。新建一个<code>Wathcer</code>对象只需要new出来，这时候<code>Dep.target</code>已经指向了这个new出来的<code>Wathcer</code>对象了。而触发<code>get</code>方法也很简单，实际上只要把render function进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过<code>console</code>模拟这个过程，读取test来触发<code>get</code>进行「依赖收集」。</p><p>再回顾一下该周期处理的应该会清晰很多。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606edad5ca9e23d?imageslim" alt="依赖收集"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么要做依赖收集？&quot;&gt;&lt;a href=&quot;#为什么要做依赖收集？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做依赖收集？&quot;&gt;&lt;/a&gt;为什么要做依赖收集？&lt;/h3&gt;&lt;p&gt;先举个例子🌰，现在有这么一个Vue对象：&lt;br&gt;&lt;figure class
      
    
    </summary>
    
    
      <category term="vue" scheme="https://kpeng.wang/tags/vue/"/>
    
      <category term="vue源码解读" scheme="https://kpeng.wang/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Ⅱ--响应式系统的基本原理</title>
    <link href="https://kpeng.wang/2018/05/20/%E2%85%A1-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://kpeng.wang/2018/05/20/Ⅱ-响应式系统的基本原理/</id>
    <published>2018-05-20T15:27:15.000Z</published>
    <updated>2018-05-20T15:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><p>Vue.js是一款MVVM框架，数据模型仅仅是普通的JavaScript对象，但是这些对象进行操作时，却能影响对应视图，它的核心实现就是 <strong>「响应式系统」</strong>。  尽管我们在使用Vue.js进行开发时不会直接修改<strong>「响应式系统」</strong>，但是理解它有助于避开一些常见的坑，也有助于在遇见一些捉摸不透的问题时可以深入其原理来解决它。</p><hr><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>首先看一下<code>Object.defineProperty</code>,Vue.js就是基于它实现 <strong>「响应式系统」</strong> 的。<br>先看使用方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*@param obj: 目标对象</span></span><br><span class="line"><span class="comment">*@param prop: 需要操作的目标对象的属性名</span></span><br><span class="line"><span class="comment">*@param descriptor: 描述符</span></span><br><span class="line"><span class="comment">*@return value 传入对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,prop,descriptor)</span><br></pre></td></tr></table></figure></p><p>其中<code>descriptor</code>的一些属性，简单介绍一下，具体可以参考<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty" target="_blank" rel="noopener">MDN文档</a>。</p><ul><li><code>enumerable</code>：属性是否可枚举，默认为<code>false</code>。</li><li><code>configurable</code>：属性是否可被修改或删除，默认为<code>false</code>。</li><li><code>get</code>：获取属性的方法。</li><li><code>set</code>：设置属性的方法。</li></ul><hr><h3 id="实现observer-可观察的"><a href="#实现observer-可观察的" class="headerlink" title="实现observer(可观察的)"></a>实现<code>observer</code>(可观察的)</h3><p>知道了<code>Objective.defineProperty</code>以后，我们来用它使对象变成可观察的。</p><p>在生命周期<code>init</code>阶段会进行初始化，对数据进行 <strong>「响应式变化」</strong>。<img src="https://user-gold-cdn.xitu.io/2017/12/19/1606e8abbababbe6?imageslim" alt="init"> </p><p>为了便于理解，在不考虑数组等复杂情况下，只对对象进行处理。</p><p>首先定义一个<code>cb</code>函数，这个函数用来模拟视图更新，内部可以是一些更新视图的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 渲染视图</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'视图已更新~'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个<code>defineReactive</code>方法，该方法通过<code>Object.defineProperty</code>来实现对对象的 <strong>「响应式化」</strong>，入参是一个需要绑定的对象<code>obj</code>、以及对象的某一个属性<code>prop</code>，具体的值<code>val</code>。经过<code>defineReactive</code>处理以后，我们的<code>obj</code>的<code>prop</code>属性在<strong>读</strong>的时候则会触发<code>reactiveSetter</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,prop,val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,prop,&#123;</span><br><span class="line">            enumerable:<span class="literal">true</span>, <span class="comment">//属性可枚举</span></span><br><span class="line">            configurable:<span class="literal">true</span>, <span class="comment">//属性可被修改或删除</span></span><br><span class="line">            get:<span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> val  <span class="comment">// 实际上会依赖收集</span></span><br><span class="line">            &#125;,</span><br><span class="line">            set:<span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(newVal === val) <span class="keyword">return</span></span><br><span class="line">                cb(newVal)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这是不够的，我们需要在上面再封装一层<code>observer</code>。这个函数传入一个<code>val</code>（需要「响应式化」的对象），再通过遍历所有属性的方式对该对象的每一个属性都经过<code>defineReactive</code>处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!val || (<span class="keyword">typeof</span> val !== <span class="string">'object'</span>)) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(val).forEach(<span class="function">(<span class="params">key</span>)=&gt;</span>&#123;</span><br><span class="line">        defineReactive(val,key,val[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，就可以使用<code>ovserver</code>来封装实现一个简易版的Vue了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span>()</span>&#123;</span><br><span class="line">    <span class="comment">// 构造类</span></span><br><span class="line">    constractor(options)&#123;</span><br><span class="line">        <span class="keyword">this</span>._data = options.data</span><br><span class="line">        observer(<span class="keyword">this</span>._data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样使用的时候就只要<code>new</code>一个Vue实例对象，就会将<code>data</code>中的数据进行「响应式化」。如果我们对<code>data</code>的属性进行如下的操作，就会触发<code>cb</code>回调更新视图。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        test:<span class="string">'a test text'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm._data.test=<span class="string">"hello,vue~"</span> <span class="comment">// -&gt; "视图已更新~"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;响应式系统&quot;&gt;&lt;a href=&quot;#响应式系统&quot; class=&quot;headerlink&quot; title=&quot;响应式系统&quot;&gt;&lt;/a&gt;响应式系统&lt;/h3&gt;&lt;p&gt;Vue.js是一款MVVM框架，数据模型仅仅是普通的JavaScript对象，但是这些对象进行操作时，却能影响对应视
      
    
    </summary>
    
    
      <category term="vue" scheme="https://kpeng.wang/tags/vue/"/>
    
      <category term="vue源码解读" scheme="https://kpeng.wang/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 常用命令</title>
    <link href="https://kpeng.wang/2018/05/18/Hexo-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://kpeng.wang/2018/05/18/Hexo-常用命令/</id>
    <published>2018-05-17T16:13:25.000Z</published>
    <updated>2018-05-17T16:13:43.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装  </span><br><span class="line">npm update hexo -g #升级  </span><br><span class="line">hexo init    #初始化</span><br></pre></td></tr></table></figure><hr><h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;  #新建文章</span><br><span class="line">hexo p == hexo publish</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure><hr><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo server 会监视文件变动并自动更新，无须重启服务器。</span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br><span class="line">hexo clean #清除缓存 网页正常情况下可以忽略此条命令，清除了db_json文件和public文件夹</span><br><span class="line">hexo g #生成静态网页</span><br><span class="line">hexo d #开始部署</span><br></pre></td></tr></table></figure><hr><h4 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate #使用 Hexo 生成静态文件快速而且简单</span><br><span class="line">hexo generate --watch #监视文件变动</span><br></pre></td></tr></table></figure><hr><h4 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo generate --deploy</span><br><span class="line">hexo deploy --generate</span><br><span class="line">or:</span><br><span class="line">hexo d -g</span><br><span class="line">hexo s -g</span><br></pre></td></tr></table></figure><hr><h4 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://kpeng.wang/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo  新开一个页面</title>
    <link href="https://kpeng.wang/2018/05/03/Hexo-%E6%96%B0%E5%BC%80%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2/"/>
    <id>https://kpeng.wang/2018/05/03/Hexo-新开一个页面/</id>
    <published>2018-05-02T18:14:04.000Z</published>
    <updated>2018-05-17T16:12:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>新建一个页面，命名为 tags 。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p>编辑刚新建的页面，将页面的<code>type</code>设置为 <code>tags</code> ，主题将自动为这个页面显示标签云。页面内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Tagcloud</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false //禁止评论</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h2 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h2><p>在菜单中添加链接。编辑 主题配置文件<code>_config.yml</code> ，添加 tags 到 menu 中，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /</span><br><span class="line">  archives: /archives</span><br><span class="line">  tags: /tags</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;步骤一&quot;&gt;&lt;a href=&quot;#步骤一&quot; class=&quot;headerlink&quot; title=&quot;步骤一&quot;&gt;&lt;/a&gt;步骤一&lt;/h2&gt;&lt;p&gt;新建一个页面，命名为 tags 。命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://kpeng.wang/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Ⅰ--Vue.js 运行机制全局概览</title>
    <link href="https://kpeng.wang/2018/05/03/%E2%85%A0-Vue.js%20%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88/"/>
    <id>https://kpeng.wang/2018/05/03/Ⅰ-Vue.js 运行机制全局概览/</id>
    <published>2018-05-02T16:38:10.000Z</published>
    <updated>2018-05-20T15:27:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>首次看这张运行机制图，可能会一头雾水。</p><p><img src="https://p.qlogo.cn/qqmail_head/hgXWbMaaqmBhXiadF2GFdBTSHeCKqmamwoJkeGWs5aDsXr0l3alkHT88go2XicPAyDWPfVI7TM75c/0" alt="vue.js生命周期图"></p><h3 id="初始化及挂载"><a href="#初始化及挂载" class="headerlink" title="初始化及挂载"></a>初始化及挂载</h3><p><img src="https://p.qlogo.cn/qqmail_head/oA62fHtPSY5lf4eYY0IVRhC3q7mC3MJXX881jOIuM6TwxpdoBOalo8YOzB2PLl8d/0" alt="mount"></p><p>在<code>new Vue()</code>之后。Vue会调用<code>_init</code>函数进行初始化，也就是这里的<code>init</code>过程，它会初始化生命周期、事件、props、methods、data、computed与watch等。其中最重要的是通过<code>Object.defineProperty</code>设置<code>setter</code>与<code>getter</code>函数，用来实现 <strong>「响应式」</strong> 以及 <strong>「依赖收集」</strong>。</p><p>初始化之后调用<code>$mount</code>会挂载组件，如果是运行时编译，即不存在render function但是存在template的情况，需要进行 <strong>「编译」</strong> 步骤。</p><hr><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>compile编译可以分成<code>parse</code>(解析)、<code>optimize</code>(优化)与<code>generate</code>(生成)三个阶段，最终需要得到render function。<br><img src="https://p.qlogo.cn/qqmail_head/PiajxSqBRaEIFBA9ACYLobEs1RyxrxFiaOLMiaP7gqpFicQSffRlGwy9X5QQKYgp1qDpx4qNJlia4Xns/0" alt="compile"></p><h4 id="parase"><a href="#parase" class="headerlink" title="parase"></a>parase</h4><p><code>parse</code>会用正则等方式解析template模板中的指令、class、style等数据，形成AST（抽象语法树–Abstract Syntax Tree）。</p><h4 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h4><p><code>optimize</code>的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当<code>update</code>更新洁面时，会有一个<code>patch</code>的过程，diff算法会直接跳过静态节点，从而减少比较的过程，优化了<code>patch</code>的性能。</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p><code>generate</code>是将AST转化成render function字符串的过程，得到结果是render的字符串以及staiticRenderFns字符串。</p><p>在经历过<code>parse</code>、<code>optimize</code>与<code>generate</code>这三个阶段之后，组建中就会存在渲染VNode所需的render function了。</p><hr><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>接下来也就是Vue.js响应式核心部分。<br><img src="https://p.qlogo.cn/qqmail_head/hgXWbMaaqmBhXiadF2GFdBTSHeCKqmamwoJkeGWs5aDuJAMOgdSHl5XBZX2eibAUHsXZW9xjOQr6c/0" alt="响应式"></p><p>这里的<code>getter</code>与<code>setter</code>已经在之前介绍过了，在<code>init</code>的时候通过<code>Object.defineProperty</code>进行了绑定，它使得当被设置的对象被读取的时候会执行<code>getter</code>函数，而当被赋值的时候会执行<code>setter</code>函数。</p><p>当render function被渲染的时候，因为会读取所需对象的值，所以会触发<code>getter</code>函数进行 <strong>「依赖收集」</strong> ，  <strong>「依赖收集」</strong> 的目的是将观察者Watcher对象存放到当前闭包中的订阅者Dep的subs中。形成如下所示的这样一个关系。<br><img src="https://p.qlogo.cn/qqmail_head/oA62fHtPSY5lf4eYY0IVRhC3q7mC3MJXbDKVm9XqSX2oKicibVaWhzQC4uj7zWNeXw/0" alt="Dep"></p><p>在修改对象值的时候，会触发对应的<code>setter</code>，<code>setter</code>通知之前 <strong>「依赖收集」</strong> 得到的Dep中的每一个Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些Watcher就会开始调用<code>update</code>来更新视图，当然这中间还有一个<code>patch</code>的过程以及使用队列来异步更新的策略。</p><hr><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>我们知道，render function 会被转化成VNode节点。虚拟DOM其实就是一颗以JavaScript对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实DOM的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于虚拟DOM是以JavaScript对象为基础而不依赖真实平台环境，所以使他具有了跨平台的能力，比如浏览器平台、Weex、Node等。</p><p>比如说下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag:<span class="string">'div'</span>,  <span class="comment">/*说明这是一个div标签*/</span></span><br><span class="line">    children:[  <span class="comment">/*存放该标签的子节点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag:<span class="string">'a'</span>,  <span class="comment">/*说明这是一个a标签*/</span></span><br><span class="line">            text:<span class="string">'click me'</span>  <span class="comment">/*标签的内容*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染后可以得到：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如isStatic（代表是否为静态节点）、isComment（代表是否为注释节点）等。</p><hr><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p><img src="https://p.qlogo.cn/qqmail_head/ajNVdqHZLLBBoBS7J0uwiacFPNtxjb0qx7BFahcf4EzgrrDiby4kicQOcwvdYz8ViaCmaL80jC1yZaM/0" alt="更新视图"></p><p>前面我们说到，在修改一个对象值的时候，会通过<code>setter-&gt;Wathcer-&gt;update</code>的流程来修改对应的视图，那么最终是如何更新视图的呢？</p><p>当数据变化后，执行render function就可以得到一个新的VNode节点，我们如果想得到新的视图，最简单粗暴的办法就是直接解析这个VNode节点，然后用<code>innerHTML</code>直接全部渲染到真实DOM中。但是其实我们只对其中的一小块内容进行修改，这样做性能似乎并非最佳。</p><p>那么我们为什么不能修改那些“改变了的地方”呢？这个时候就要用到我们的<code>「patch」</code>了。 我们会将新的VNode与旧的Vnode一起传入<code>patch</code>进行比较，经过diff算法得出它们的 <strong>「差异」</strong>。最后我们将需要这些 <strong>「差异」</strong> 的对应DOM进行修改即可。</p><hr><h3 id="再看全局"><a href="#再看全局" class="headerlink" title="再看全局"></a>再看全局</h3><p><img src="https://p.qlogo.cn/qqmail_head/hgXWbMaaqmBhXiadF2GFdBTSHeCKqmamwoJkeGWs5aDsXr0l3alkHT88go2XicPAyDWPfVI7TM75c/0" alt="vue.js生命周期图"></p><p>回过头再来看看这张图，大脑中应该已经有了一个大概的脉络了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首次看这张运行机制图，可能会一头雾水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p.qlogo.cn/qqmail_head/hgXWbMaaqmBhXiadF2GFdBTSHeCKqmamwoJkeGWs5aDsXr0l3alkHT88go2XicPAyDWPf
      
    
    </summary>
    
    
      <category term="vue" scheme="https://kpeng.wang/tags/vue/"/>
    
      <category term="vue源码解读" scheme="https://kpeng.wang/tags/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题集锦( ES篇)</title>
    <link href="https://kpeng.wang/2018/04/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6(%20ES%E7%AF%87)/"/>
    <id>https://kpeng.wang/2018/04/27/前端面试题集锦( ES篇)/</id>
    <published>2018-04-26T17:37:20.000Z</published>
    <updated>2018-04-25T16:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="请描述一下-JavaScript-事件冒泡机制？"><a href="#请描述一下-JavaScript-事件冒泡机制？" class="headerlink" title="请描述一下 JavaScript 事件冒泡机制？"></a>请描述一下 JavaScript 事件冒泡机制？</h5><p><img src="http://upload-images.jianshu.io/upload_images/3117374-851c2c19c5b5a022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JS事件捕获与冒泡原型图"></p><blockquote><p>当页面中某个元素的事件被触发以后，比如点击了页面中的某个按钮，<br>就触发了当前按钮的点击事件，但是 JavaScript 并不是简单就直接触发该元素的相应事件，<br>而是会首先从 DOM 树的最顶层（window）依次的去触发目标（被直接点击的）元素所有父级的同类事件，<br>直到触发到目标元素，然后又会再一次的从目标元素开始触发其所有父级的所有同类事件直到window，<br>也就是同类型事件的目标元素与 window 之间触发一个来回，<br>window 到目标的触发阶段，我们称为捕获阶段，<br>目标触发事件的时候我们称为目标阶段，<br>而最后目标到 window 的触发阶段，我们称为冒泡阶段。<br>这种机制我们称为<em>事件流（event flow）</em>，冒泡机制其实就是事件流机制中的冒泡阶段规则。</p></blockquote><blockquote><p>出处：<a href="https://www.w3.org/TR/2016/WD-uievents-20160804/" target="_blank" rel="noopener">https://www.w3.org/TR/2016/WD-uievents-20160804/</a> 中的<br>3.1. Event dispatch and DOM event flow</p></blockquote><hr><h5 id="JavaScript-的事件流模型都有什么？"><a href="#JavaScript-的事件流模型都有什么？" class="headerlink" title="JavaScript 的事件流模型都有什么？"></a>JavaScript 的事件流模型都有什么？</h5><p>分析：<br>事件流模型这个知识点在妙味中级阶段 event 事件章节就有详细讲解，如果已经忘记的朋友，再去看看这个阶段的视频吧。 题外话：一般纯理论的知识点学起来枯燥（妙味实体班的学员也是如此），但理论的好处在于当遇到问题时，能迅速判断出错的原理所在，从而可以准确迅速的查找问题并精准修复，可以让冗余代码简化到最低、可以不再出了错以后像撞大运般的采用 “试来试去大法” 来修复~</p><blockquote><p>事件流描述的是从页面中接收事件的顺序。 DOM 结构是树形结构，当页面中的某一个元素触发了某个一个事件，事件会从最顶层的 window 对象开始，向下传播到目标元素，途径的祖先节点都会触发对应的事件，如果当前节点的该事件绑定了事件处理函数的话，则会执行该函数当事件达到目标元素并执行绑定函数（如果有绑定的话）后，事件又会向上传播到 window 元素，途径的祖先节点都会触发对应的事件（如果绑定事件处理函数的话）</p></blockquote><p>事件流包含三个阶段：</p><blockquote><ul><li>事件捕捉阶段：事件开始由顶层对象触发，然后逐级向下传播，直到目标的元素；</li><li>处于目标阶段：处在绑定事件的元素上；</li><li>事件冒泡阶段：事件由具体的元素先接收，然后逐级向上传播，直到不具体的元素；</li></ul></blockquote><hr><p>#####什么是闭包（closure），为什么要用它？</p><blockquote><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。<br><strong>闭包的特性</strong>：</p><ol><li>函数内再嵌套函数 </li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ol></blockquote><hr><h5 id="BOM-对象有哪些，列举-window-对象？"><a href="#BOM-对象有哪些，列举-window-对象？" class="headerlink" title="BOM 对象有哪些，列举 window 对象？"></a>BOM 对象有哪些，列举 window 对象？</h5><blockquote><ul><li>window 对象，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；</li><li>location 对象，浏览器当前URL信息；</li><li>navigator 对象，浏览器本身信息；</li><li>screen 对象，客户端屏幕信息；</li><li>history 对象，浏览器访问历史信息；</li></ul></blockquote><hr><h5 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h5><blockquote><ol><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 </li><li>属性和方法被加入到 this 引用的对象中。</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ol></blockquote><hr><h5 id="“-”-和-“-”-有什么不同"><a href="#“-”-和-“-”-有什么不同" class="headerlink" title="“==” 和 “===” 有什么不同?"></a>“==” 和 “===” 有什么不同?</h5><blockquote><ol><li>相同的是：== 和 === 都是比较等值比较运算符，返回的布尔类型的比较结果。</li><li>不同的是：<ul><li>== 是等值比较运算符，使用的是 抽象等值 比较算法。<br> === 是严格等值比较运算符，使用的 严格等值 比较算法。</li><li>== 运算符在比较值的时候，会根据两者类型是否相同而做不同的处理，<br>在两者不同类型的时候，会转换类型后进行比较：<br>基本类型会转成数字，引用类型会转成对象原始值，然后再进行比较。<br>而 === 首先也会判断类型是否一致，不同的是如果类型不一致则直接返回 false。</li></ul></li></ol></blockquote><blockquote><p>资料参考：</p><ul><li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1" target="_blank" rel="noopener">等值比较运算符 ( == )</a></li><li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" target="_blank" rel="noopener">抽象比较算法</a></li><li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.4" target="_blank" rel="noopener">严格等值比较运算符 ( === )</a></li><li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.6" target="_blank" rel="noopener">严格比较算法</a></li></ul></blockquote><hr><h5 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h5><blockquote><p>使用<code>instanceof</code></p></blockquote><hr><p>#####Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hasOwnProperty</span><br></pre></td></tr></table></figure></blockquote><ul><li>hasOwnProperty函数方法是返回一个布尔值，</li><li>指出一个对象是否具有指定名称的属性。</li><li>此方法无法检查该对象的原型链中是否具有该属性；</li><li>该属性必须是对象本身的一个成员。<br>+如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。</li></ul><hr><h5 id="window-foo-window-foo-“bar”-返回值是什么？"><a href="#window-foo-window-foo-“bar”-返回值是什么？" class="headerlink" title="window.foo || (window.foo = “bar”); 返回值是什么？"></a>window.foo || (window.foo = “bar”); 返回值是什么？</h5><blockquote><p>参考答案：<br>“bar”</p></blockquote><blockquote><p>分析：<br>|| 又称为短路或，短路：如果左侧为真，则不再进行右侧运算，同时返回左侧表达式运算结果。<br>如果左侧为假则执行右侧表达式运算，并返回右侧计算结果。<br>上面window.foo是不存在的，所有结果为undefined，转成boolean就是false，<br>那么就会运算 window.foo = “bar”，<br>把 “bar” 赋值给 window.foo 的同时，<br>返回值也是 “foo”，所以打印返回结果是 “bar”</p></blockquote><hr><h5 id="JavaScript-的-typeof-返回哪些数据类型？"><a href="#JavaScript-的-typeof-返回哪些数据类型？" class="headerlink" title="JavaScript 的 typeof 返回哪些数据类型？"></a>JavaScript 的 typeof 返回哪些数据类型？</h5><blockquote><ul><li><strong>基础类型</strong>包括：Number、String、Boolean、Null、Undefined、Symbol（该类型位 ES2015 中新增类型）</li><li><strong>引用类型</strong>包括：Object typeof 运算符把类型信息以字符串形式返回，需要注意的是 typeof 返回的类型和 JavaScript 定义的类型有细微的差异。 typeof 返回七种可能的值：“number”、“string”、“boolean”、“object”、”symbol”、“function”和“undefined”。</li></ul></blockquote><hr><h5 id="请写出以下运算结果："><a href="#请写出以下运算结果：" class="headerlink" title="请写出以下运算结果："></a>请写出以下运算结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof null);   // object</span><br><span class="line">alert(typeof undefined);  // undefined</span><br><span class="line">alert(typeof NaN);  // number</span><br><span class="line">alert(NaN == undefined);   // false</span><br><span class="line">alert(NaN == NaN);  // false</span><br><span class="line"></span><br><span class="line">var str = &quot;123abc&quot;;</span><br><span class="line">alert(typeof str++);   // number</span><br><span class="line">alert(str); // NaN</span><br></pre></td></tr></table></figure><hr><h5 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h5><blockquote><ul><li><strong> null</strong>表示空值，转为数值时为0；</li><li><strong>undefined</strong>表示”缺少值”，就是此处应该有一个值，但是还没有定义。</li><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ul></blockquote><hr><h5 id="例举至少-3-种强制类型转换和-2-种隐式类型转换"><a href="#例举至少-3-种强制类型转换和-2-种隐式类型转换" class="headerlink" title="例举至少 3 种强制类型转换和 2 种隐式类型转换?"></a>例举至少 3 种强制类型转换和 2 种隐式类型转换?</h5><blockquote><ol><li>强制类型转换： 明确调用内置函数，强制把一种类型的值转换为另一种类型。强制类型转换主要有：Boolean、Number、String、parseInt、parseFloat</li></ol></blockquote><blockquote><ol start="2"><li>隐式类型转换： 在使用算术运算符时，运算符两边的数据类型可以是任意的，比如，一个字符串可以和数字相加。之所以不同的数据类型之间可以做运算，是因为 JavaScript 引擎在运算之前会悄悄的把他们进行了隐式类型转换。隐式类型转换主要有：+、–、==、!</li></ol></blockquote><hr><h5 id="“-foo-div-bar-eq-0-”-请优化这段-JQuery-选择器？"><a href="#“-foo-div-bar-eq-0-”-请优化这段-JQuery-选择器？" class="headerlink" title="$(“.foo div#bar:eq(0)”) 请优化这段 JQuery 选择器？"></a>$(“.foo div#bar:eq(0)”) 请优化这段 JQuery 选择器？</h5><blockquote><p>参考答案：</p></blockquote><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#bar:eq(0)&quot;)</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>分析：<br>因为有 id 选择器，所以前面的 .foo div 是没有必要的。</p></blockquote><hr><h5 id="请解释-JQuery-中-end-的用途？"><a href="#请解释-JQuery-中-end-的用途？" class="headerlink" title="请解释 JQuery 中 .end() 的用途？"></a>请解释 JQuery 中 .end() 的用途？</h5><blockquote><p>参考答案：</p></blockquote><blockquote><p>返回当前jq对象的上级jq对象</p></blockquote><blockquote><p>分析：</p></blockquote><blockquote><ol><li>当我们通过$()会得到一个对象 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$jq1 = $(&apos;#div1&apos;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>jq对象下有一系列的方法，有的方法会返回一个新的对象<br>// 通过$jq1的find返回了一个新的jquery对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var $jq2 = $jq1.find(&apos;p&apos;);</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>这个时候在$jq2下面有一个属性 prevObject，该属性保存的就是 $jq1，通过比较 $jq2.prevObject == $jq1，会发现返回true。</li></ol></blockquote><blockquote><ol start="4"><li>通过 prevObject 属性会产生一个类似原型链的引用，<br>而 .end() 方法就是返回就是当前 JQ 对象的 prevObject 对象，<br>也就是当我们 $jq2.end() 的时候，返回的就是上层的 $jq1。</li></ol></blockquote><hr><h5 id="注册账号要求以字母开头，可以包含字母、数字、下划线，请写出验证该账号的正则表达式？"><a href="#注册账号要求以字母开头，可以包含字母、数字、下划线，请写出验证该账号的正则表达式？" class="headerlink" title="注册账号要求以字母开头，可以包含字母、数字、下划线，请写出验证该账号的正则表达式？"></a>注册账号要求以字母开头，可以包含字母、数字、下划线，请写出验证该账号的正则表达式？</h5><blockquote><p>参考答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[a-zA-Z]\w+$/</span><br></pre></td></tr></table></figure></p></blockquote><hr><h5 id="请列举三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）"><a href="#请列举三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）" class="headerlink" title="请列举三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）"></a>请列举三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）</h5><blockquote><p>参考答案：</p></blockquote><blockquote><ol><li>减少实际加载时间<ol><li>减少 http 请求（合并文件、合并图片）</li><li>压缩 JavaScript、CSS 代码</li><li>启用服务器压缩传输（如 gzip）</li></ol></li></ol></blockquote><blockquote><ol start="2"><li>减少感知时间<ol><li>script 外部脚本加载放到 html 最后进行</li><li>按需加载资源（如：只加载当前能看到的区域的图片）</li></ol></li></ol></blockquote><hr><h5 id="“I’m-lasagna-hog”-split-“”-reverse-jion-“”-语句的返回值是什么？"><a href="#“I’m-lasagna-hog”-split-“”-reverse-jion-“”-语句的返回值是什么？" class="headerlink" title="“I’m lasagna hog”.split(“”).reverse().jion(“”); 语句的返回值是什么？"></a>“I’m lasagna hog”.split(“”).reverse().jion(“”); 语句的返回值是什么？</h5><blockquote><p>参考答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goh angasal m&apos;I</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>分析：</p></blockquote><blockquote><ol><li>split(“”)，拆分字符串，得到数组：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;I&quot;, &quot;&apos;&quot;, &quot;m&quot;, &quot; &quot;, &quot;l&quot;, &quot;a&quot;, &quot;s&quot;, &quot;a&quot;, &quot;g&quot;, &quot;n&quot;, &quot;a&quot;, &quot; &quot;, &quot;h&quot;, &quot;o&quot;, &quot;g&quot;]</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="2"><li>对数组使用.reverse()，翻转数组，得到：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;g&quot;, &quot;o&quot;, &quot;h&quot;, &quot; &quot;, &quot;a&quot;, &quot;n&quot;, &quot;g&quot;, &quot;a&quot;, &quot;s&quot;, &quot;a&quot;, &quot;l&quot;, &quot; &quot;, &quot;m&quot;, &quot;&apos;&quot;, &quot;I&quot;]</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="3"><li>最后使用join(“”)，把数组再次拼接成字符串，得到字符串：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goh angasal m&apos;I</span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><h5 id="function-console-log-1-和-window-onload-function-console-log-2-执行结果？详细说明原因？"><a href="#function-console-log-1-和-window-onload-function-console-log-2-执行结果？详细说明原因？" class="headerlink" title="$(function(){console.log(1)}); 和 window.onload = function(){console.log(2)};执行结果？详细说明原因？"></a>$(function(){console.log(1)}); 和 window.onload = function(){console.log(2)};执行结果？详细说明原因？</h5><blockquote><p>参考答案：</p></blockquote><blockquote><p>先输出2，再输出1</p></blockquote><blockquote><p>分析：</p></blockquote><blockquote><p>这里重点是：JQ 的 $(function(){}) 和 window.onload = function(){}，并不等同</p></blockquote><blockquote><ol><li><strong>window.onload </strong>是页面资源加载完成后触发的事件，<br>比如页面中有图片需要加载，那么onload是等图片加载完成以后才触发的。</li></ol></blockquote><blockquote><ol start="2"><li><strong>$(function) </strong>监听的是 DOMContentLoaded 事件，而该事件只需要把 HTML 结构加载完成就会触发<br>（一般我们js操作的就是页面元素，所以只需要等结构加载完成能操作页面元素就可以了）<br>所以该事件会比 onload 事件要先触发，所以 2 先执行。</li></ol></blockquote><hr><h5 id="请指出-JQuery中-“-bind-”、”-live-”-和-“delegate-”-的区别？"><a href="#请指出-JQuery中-“-bind-”、”-live-”-和-“delegate-”-的区别？" class="headerlink" title="请指出 JQuery中 “.bind()”、”.live()” 和 “delegate()” 的区别？"></a>请指出 JQuery中 “.bind()”、”.live()” 和 “delegate()” 的区别？</h5><blockquote><p>参考答案：</p></blockquote><blockquote><ol><li>bind：把函数直接绑定到指定元素的指定事件上。</li><li>live：把函数绑定到document上，接收选择器和事件类型作为参数，当触发一个元素的事件的时候，会利用事件冒泡到document上这一特性，判断事件目标元素和绑定参数中的选择器是否匹配，如果匹配则执行绑定函数的执行。</li><li>delegate：和live有点类似，但是可以指定绑定元素，而不是document，其他和live一致，但是比live更加灵活。</li></ol></blockquote><hr><h5 id="请使用标准的-JSON-格式封装一组学生信息数据，内容包括：姓名、性别、住址（包括城市、街道、门牌号、地铁线）"><a href="#请使用标准的-JSON-格式封装一组学生信息数据，内容包括：姓名、性别、住址（包括城市、街道、门牌号、地铁线）" class="headerlink" title="请使用标准的 JSON 格式封装一组学生信息数据，内容包括：姓名、性别、住址（包括城市、街道、门牌号、地铁线）"></a>请使用标准的 JSON 格式封装一组学生信息数据，内容包括：姓名、性别、住址（包括城市、街道、门牌号、地铁线）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;北京妙味&quot;,</span><br><span class="line">        &quot;gender&quot;: &quot;男&quot;,</span><br><span class="line">        &quot;address&quot;: &#123;</span><br><span class="line">            &quot;city&quot;: &quot;北京&quot;,</span><br><span class="line">            &quot;street&quot;: &quot;西二旗辉煌国际&quot;</span><br><span class="line">            &quot;RoomNo&quot;: &quot;6楼319室&quot;,</span><br><span class="line">            &quot;subwayLine&quot;: &quot;13&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;上海妙味&quot;,</span><br><span class="line">        &quot;gender&quot;: &quot;男&quot;,</span><br><span class="line">        &quot;address&quot;: &#123;</span><br><span class="line">            &quot;city&quot;: &quot;上海&quot;,</span><br><span class="line">            &quot;street&quot;: &quot;闵行区新龙路七宝宝龙城&quot;</span><br><span class="line">            &quot;RoomNo&quot;: &quot;T4楼9层902室&quot;,</span><br><span class="line">            &quot;subwayLine&quot;: &quot;9&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h5 id="客户查询手机消费清单要求："><a href="#客户查询手机消费清单要求：" class="headerlink" title="客户查询手机消费清单要求："></a>客户查询手机消费清单要求：</h5><p>实现 A、B、C 三个异步接口，A 接口需传参 user_name、mobi（用户姓名和手机号码），请求成功返回该用户此手机号码的消费清单信息，user_name 可通过接口 B 获取，mobi 可通过接口 C 获取，请使用 JQuery 写出具体的实现方法？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.ajax(<span class="string">'/get_user_name.php'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMobi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.ajax(<span class="string">'/get_mobi.php'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$.when(getUserName(), getMobi()).then(<span class="function"><span class="keyword">function</span>(<span class="params">data1, data2</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'getConsumerList.php'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            user_name: data1[<span class="number">0</span>],</span><br><span class="line">            mobi: data2[<span class="number">0</span>],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).success(<span class="function"><span class="keyword">function</span>(<span class="params">consumerList</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//consumerList</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取用户名或手机号未成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h5 id="请简述-AJAX-及基本步骤？"><a href="#请简述-AJAX-及基本步骤？" class="headerlink" title="请简述 AJAX 及基本步骤？"></a>请简述 AJAX 及基本步骤？</h5><blockquote><ul><li>初始化ajax对象</li><li>连接地址，准备数据</li><li>发送请求</li><li>接收数据（正在接收，尚未完成）</li><li>接收数据完成</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//初始化ajax对象</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">//连接地址，准备数据</span><br><span class="line">xhr.open(“方式”,”地址”,是否为异步);</span><br><span class="line">//接收数据完成触发的事件</span><br><span class="line">xhr.onload =function()&#123;&#125;</span><br><span class="line">//发送数据</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><hr><h5 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h5><blockquote><p>normaldefer和async、动态创建DOM方式（用得最多）、按需异步载入js</p></blockquote><hr><h5 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别?"></a>同步和异步的区别?</h5><p>概念1：<strong>同步异步可以说是对被请求方来说的，被请求者使用什么方式来告知处理结果。</strong></p><blockquote><ul><li>首先同步异步于阻塞非阻塞并没有关系。同步异步主要是事情做完以后，如何进行处理、或者说关注的是一 种消息通信机制。</li><li>同步的情况下，是由处理消息者自己去等待消息是否被触发；</li><li>异步的情况下是由触发机制来通知处理消息者；</li></ul></blockquote><p>概念2：<strong>同步可以是阻塞的也可以是非阻塞的，异步也是如此。</strong></p><blockquote><ul><li>阻塞非阻塞，主要是对于请求者而言的。</li><li>阻塞：发出请求等待结果返回，然后再处理后续的事情；</li><li>非阻塞：发出请求不等待结果返回，可以接着做后续的事情；</li></ul></blockquote><hr><h5 id="GET和POST的区别，何时使用POST？"><a href="#GET和POST的区别，何时使用POST？" class="headerlink" title="GET和POST的区别，何时使用POST？"></a>GET和POST的区别，何时使用POST？</h5><blockquote><ul><li>GET：一般用于查询数据，使用URL传递参数，由于浏览器对地址栏长度有限制，所以对使用get方式所发送信息的数量有限制，同时浏览器会记录（历史记录，缓存）中会保留请求地址的信息，包括地址后面的数据。get 只能发送普通格式（URL 编码格式）的数据。</li><li>POST：一般用于向服务器发送数据，对所发送的数据的大小理论上是没有限制，浏览器会缓存记录地址，但是不会记录 post 提交的数据。post 可以发送纯文本、URL编码格式、二进制格式的字符串，形式多样。</li><li>在以下情况中，请使用 POST 请求：<ol><li>以提交为目的的请求（类似语义化，get 表示请求，post 表示提交）；</li><li>发送私密类数据（用户名、密码）（因为浏览器缓存记录特性）；</li><li>向服务器发送大量数据（数据大小限制区别）；</li><li>上传文件图片时（数据类型区别）；</li></ol></li></ul></blockquote><hr><h5 id="AJAX-的局限性"><a href="#AJAX-的局限性" class="headerlink" title="AJAX 的局限性?"></a>AJAX 的局限性?</h5><blockquote><ul><li>AJAX 不支持浏览器 back 按钮。</li><li>安全问题 AJAX 暴露了与服务器交互的细节。</li><li>对搜索引擎的支持比较弱。不会执行你的 JS 脚本，只会操作你的网页源代码；</li><li>跨域请求有一定限制。解决方式：jsonp；</li></ul></blockquote><hr><h5 id="new-操作符具体干了什么呢"><a href="#new-操作符具体干了什么呢" class="headerlink" title="new 操作符具体干了什么呢?"></a>new 操作符具体干了什么呢?</h5><blockquote><p>当使用 new 操作符调用构造函数，函数实际会经历如下步骤：</p><ul><li>创建一个新对象；</li><li>把函数中上下文（作用域）对象this指向该对象；</li><li>执行代码，通过this给新对象添加属性或方法；</li><li>返回对象；</li></ul></blockquote><hr><h5 id="JavaScript-原型，原型链-有什么特点？"><a href="#JavaScript-原型，原型链-有什么特点？" class="headerlink" title="JavaScript 原型，原型链 ? 有什么特点？"></a>JavaScript 原型，原型链 ? 有什么特点？</h5><blockquote><ul><li><strong>JavaScript 原型</strong>： 每创建一个函数，函数上都有一个属性为 prototype，它的值是一个对象。 这个对象的作用在于当使用函数创建实例的时候，那么这些实例都会共享原型上的属性和方法。</li><li><strong>原型链</strong>： 在 JavaScript 中，每个对象都有一个指向它的原型（prototype）对象的内部链接（proto）。这个原型对象又有自己的原型，直到某个对象的原型为 null 为止（也就是不再有原型指向）。这种一级一级的链结构就称为原型链（prototype chain）。 当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止;到查找到达原型链的顶部（Object.prototype），仍然没有找到指定的属性，就会返回 undefined。</li></ul></blockquote><hr><h5 id="实现对数组进行乱序"><a href="#实现对数组进行乱序" class="headerlink" title="实现对数组进行乱序"></a>实现对数组进行乱序</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">var</span> sign = <span class="number">1</span>; </span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h5 id="实现一个函数-clone-，可以对-JavaScript-中的5种主要的数据类型（包括-Number、String、Object、Array、Boolean）进行值复制。"><a href="#实现一个函数-clone-，可以对-JavaScript-中的5种主要的数据类型（包括-Number、String、Object、Array、Boolean）进行值复制。" class="headerlink" title="实现一个函数 clone()，可以对 JavaScript 中的5种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制。"></a>实现一个函数 clone()，可以对 JavaScript 中的5种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制。</h5><blockquote><p>这道题考察了以下知识点：</p><ul><li>使用 typeof 判断值得类型；</li><li>使用 toString 区分数组和对象；</li><li>递归函数的使用；</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是对象，就进行循环复制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">'null'</span>) &#123;</span><br><span class="line">        <span class="comment">// 区分是数组还是对象，创建空的数组或对象</span></span><br><span class="line">        <span class="keyword">var</span> o = <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">"Array"</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="comment">// 如果属性对应的值为对象，则递归复制</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[k] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj[k] !== <span class="string">'null'</span>)&#123;</span><br><span class="line">                o[k] = clone(obj[k])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                o[k] = obj[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//不为对象，直接把值返回</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="判断代码输出结果"><a href="#判断代码输出结果" class="headerlink" title="判断代码输出结果"></a>判断代码输出结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var test = 2;</span><br><span class="line">console.log(&quot;test is a Number--&quot; + (test.constructor == Number));  //true</span><br><span class="line">function test1() &#123;&#125;;</span><br><span class="line">var t1 = new test1();</span><br><span class="line">var test2 = &quot;37degree&quot;;</span><br><span class="line"></span><br><span class="line">console.info(&quot;typeof test--&quot; + typeof test); //number</span><br><span class="line">console.info(&quot;typeof test1--&quot; + typeof test1);  //function</span><br><span class="line">console.info(&quot;typeof t1--&quot; + typeof t1);  //object</span><br><span class="line">console.info(&quot;t1 instanceof test1--&quot; + (t1 instanceof Object));   //true</span><br><span class="line">console.info(&quot;test instanceof Array--&quot; + (test instanceof Array));  //false</span><br></pre></td></tr></table></figure><blockquote><p>首先涉及到 JS 预解析的概念，这里的 变量申明 和 函数申明 都会被预解析处理，知道这个以后，那么下面一个一个来分析：</p></blockquote><blockquote><ul><li>第一个：<br>因为 test = 2 先执行了，所以这里 test 的值已经是一个数字了，那么 test.constructr 就是 Number，所以下面这个打印 true；<br>console.log(“test is a Number–” + (test.constructr == Number))</li></ul></blockquote><blockquote><ul><li>第二个：<br>原因同上，需要注意 typeof 得到的结果 number 的 n 是小写的！</li></ul></blockquote><blockquote><ul><li>第三个：<br>test1 是一个函数，typeof 值为 function；</li></ul></blockquote><blockquote><ul><li>第四个：<br>通过 new 得到的结果一定是一个 Object，所以 t1 的 typeof 结果为 object；</li></ul></blockquote><blockquote><ul><li>第五个：<br>这个题有点误导人的，首先出题人写的是 instanceof test1，但真正计算的却是 instanceof Object，请注意它们的差异！不过不影响结果的，结果都是 true；</li></ul></blockquote><blockquote><ul><li>第六个：<br>test 是一个数字，所以他的构造函数应是 Number，而不是 Array，所以结果为 false；</li></ul></blockquote><hr><h5 id="解释-call-与-apply-的区别，并写出下面代码输出的结果："><a href="#解释-call-与-apply-的区别，并写出下面代码输出的结果：" class="headerlink" title="解释 call 与 apply 的区别，并写出下面代码输出的结果："></a>解释 call 与 apply 的区别，并写出下面代码输出的结果：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    alert(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    alert(a - b);</span><br><span class="line">&#125;</span><br><span class="line">add.call(sub, <span class="number">3</span>, <span class="number">1</span>)  <span class="comment">//结果为 4</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>call 和 apply 都是函数下的一个静态方法，可以通过函数 .call() 或 函数 .apply() 的方式来间接调用该函数，通过 call 或 apply 执行时候的第一个参数改变该函数执行过程中的上下文对象（this），如果第一个参数不存在或者设置成 null/undefined，那么该函数执行过程中的上下文对象指向全局上下文对象，在 JavaScript 中指向了 window 对象。</li></ul></blockquote><blockquote><ul><li>不同之处在于后续参数上，call 第一个参数以后的参数值将被一一对应的赋值给源函数的形参，而 apply 则是传入一个数组，间接传给函数的 arguments 对象。</li></ul></blockquote><hr><h5 id="研究下面-JS-代码是否有问题，有问题请描述问题并解决，没有问题请回答最终结果。"><a href="#研究下面-JS-代码是否有问题，有问题请描述问题并解决，没有问题请回答最终结果。" class="headerlink" title="研究下面 JS 代码是否有问题，有问题请描述问题并解决，没有问题请回答最终结果。"></a>研究下面 JS 代码是否有问题，有问题请描述问题并解决，没有问题请回答最终结果。</h5><p>代码一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">sayHi();</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    a = a + 10;</span><br><span class="line">    console.log(a);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">console.info(a);</span><br><span class="line">console.info(sayHi() + 10);</span><br></pre></td></tr></table></figure></p><p>代码一分析:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//申明全局 a，值为 10</span><br><span class="line">var a = 10;</span><br><span class="line">sayHi();  //调用</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    a = a + 10;  //这里的 a 是全局的 a，而不是局部的，所以执行的结果是把全局 a 设置成了 20</span><br><span class="line">    console.log(a);  //20</span><br><span class="line">    return a;  //返回 20</span><br><span class="line">&#125;</span><br><span class="line">console.info(a);  //全局 a 已经是 20 了</span><br><span class="line">console.info(sayHi() + 10);  //首先又一次执行了 sayHi()，结果把 a 改成了 30，然后打印了一次 30，执行完以后返回了 30，然后在加 10，打印结果 40</span><br></pre></td></tr></table></figure></p><p>代码二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">sayHi();</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    var a = a + 10;</span><br><span class="line">    console.info(a);</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">console.info(a);</span><br><span class="line">console.info(sayHi() + 10);</span><br></pre></td></tr></table></figure></p><p>代码二分析:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//申明全局 a，值为 10</span><br><span class="line">var a = 10;</span><br><span class="line">//调用</span><br><span class="line">sayHi();</span><br><span class="line">function sayHi() &#123;</span><br><span class="line">    //注意这里有一个 var，那么这里的 a 就是局部变量了，另外还是需要预解析一下，其实可以这么去看代码：</span><br><span class="line">    /*</span><br><span class="line">    var a;  //申明未赋值，默认值是 undefined</span><br><span class="line">    a = a + 10;  // a = undefined + 10 结果是 NaN</span><br><span class="line">    */</span><br><span class="line">    var a = a + 10;</span><br><span class="line">    console.info(a);  // NaN</span><br><span class="line">    return a;  //返回 NaN</span><br><span class="line">&#125;</span><br><span class="line">console.info(a);  //这个还是全局的 a，所以结果 10</span><br><span class="line">console.info(sayHi() + 10); //依据上面的分析，这里的 sayHi 会打印一次 NaN，然后加 10，结果还是 NaN</span><br></pre></td></tr></table></figure></p><p>代码三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function init() &#123;</span><br><span class="line">    var ps = document.getElementsByTagName(&quot;p&quot;);  //body内有四个p标签</span><br><span class="line">    for (var i=0; i&lt;ps.length; i++) &#123;</span><br><span class="line">        ps[i].onclick = function() &#123;</span><br><span class="line">            console.info(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码三分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 1. console.info(i); 的执行是需要用户点击后执行的，当用户点击的时候，for 循环的执行已经结束，那么 i 的值已经被设置成了 4，也就说当用户去点击的时候 i 的值已经是 4 了；</span><br><span class="line">// 2. 当 console.info(i); 执行的时候，会根据作用域链去查找 i，这样会找到 for 中定义的全局 i，这个时候不管点击那个 p 标签其实打印的都是全局 i 变量，所以结果都是统一的 4；</span><br><span class="line"></span><br><span class="line">// 解决方案一：</span><br><span class="line">function init() &#123;</span><br><span class="line">    var ps = document.getElementsByTagName(&quot;p&quot;);</span><br><span class="line">    for (var i=0; i&lt;ps.length; i++) &#123;</span><br><span class="line">        (function(n) &#123;</span><br><span class="line">            ps[n].onclick = function() &#123;</span><br><span class="line">                console.info(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解决方案二：</span><br><span class="line">function init() &#123;</span><br><span class="line">    var ps = document.getElementsByTagName(&quot;p&quot;);</span><br><span class="line">    for (let i=0; i&lt;ps.length; i++) &#123;</span><br><span class="line">        ps[i].onclick = function() &#123;</span><br><span class="line">            console.info(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h5 id="设计一个列表，包含：地域、人数、百分比、时间。请实现按照-人数-与-时间-的排序算法。"><a href="#设计一个列表，包含：地域、人数、百分比、时间。请实现按照-人数-与-时间-的排序算法。" class="headerlink" title="设计一个列表，包含：地域、人数、百分比、时间。请实现按照 人数 与 时间 的排序算法。"></a>设计一个列表，包含：地域、人数、百分比、时间。请实现按照 人数 与 时间 的排序算法。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">var data = [</span><br><span class="line">    &#123;</span><br><span class="line">        area: &apos;深圳&apos;,</span><br><span class="line">        percentage: 15,</span><br><span class="line">        number: 80,</span><br><span class="line">        staytime: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        area: &apos;北京&apos;,</span><br><span class="line">        percentage: 30,</span><br><span class="line">        number: 150,</span><br><span class="line">        staytime: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        area: &apos;广州&apos;,</span><br><span class="line">        percentage: 25,</span><br><span class="line">        number: 60,</span><br><span class="line">        staytime: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        area: &apos;上海&apos;,</span><br><span class="line">        percentage: 30,</span><br><span class="line">        number: 100,</span><br><span class="line">        staytime: 4</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 根据指定的字段和规则排序数据</span><br><span class="line">* data Array 要排序的数据</span><br><span class="line">* field string 排序依据的字段</span><br><span class="line">* rule string 排序规则 DESC / ASC</span><br><span class="line">* throw </span><br><span class="line">*       data is invalid : 要排序的数据不存在或类型不正确</span><br><span class="line">*       field is invalid : 排序参考字段不存在</span><br><span class="line">* return Array 排序后的数据</span><br><span class="line">*/</span><br><span class="line">function mySort(data, field, rule) &#123;</span><br><span class="line">    if (!(data instanceof Array)) &#123;</span><br><span class="line">        throw new TypeError(&apos;data is invalid&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !(field in data[0]) ) &#123;</span><br><span class="line">        throw new RangeError(&apos;field is invalid&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !rule || [&apos;DESC&apos;,&apos;ASC&apos;].indexOf( (rule = rule.toString().toUpperCase()) ) == -1 ) &#123;</span><br><span class="line">        rule = &apos;DESC&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    data.sort(function(a, b) &#123;</span><br><span class="line">        var v = a[field] - b[field];</span><br><span class="line">        return rule == &apos;ASC&apos; ? v : -v;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mySort(data, &apos;number&apos;, &apos;desc&apos;);</span><br><span class="line">console.dir( data );</span><br></pre></td></tr></table></figure><hr><h5 id="请列举一些浏览器兼容性问题？以及提高性能方面的方案"><a href="#请列举一些浏览器兼容性问题？以及提高性能方面的方案" class="headerlink" title="请列举一些浏览器兼容性问题？以及提高性能方面的方案"></a>请列举一些浏览器兼容性问题？以及提高性能方面的方案</h5><blockquote><p><strong>JS兼容问题</strong></p><ol><li>JSON 解析问题：<br>ecmascript5 通过 JSON 对象进行处理，ecmascript5 之前通过 eval 进行解析；</li></ol></blockquote><blockquote><ol start="2"><li>自定义属性问题：<br>IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；<br>Firefox下，只能使用 getAttribute( )获取自定义属性。<br>解决方法：<br>统一通过 getAttribute() 获取自定义属性，不过更推荐直接通过 “点” 运算符访问元素属性。</li></ol></blockquote><blockquote><ol start="3"><li>事件对象兼容性问题：<br>非标准 IE 和 chrome 下可以通过全局 event 对象来获取，标准（包括标准 IE，chrome 等）浏览器通过事件函数的第一个参数传入。</li></ol></blockquote><blockquote><ol start="4"><li>事件源对象<br>IE 下使用 event.srcElement，标准下使用 event.target 来获取。</li></ol></blockquote><blockquote><ol start="5"><li>阻止事件冒泡<br>通常可以通过 event.cancelBubble = false 来阻止，但是标准推荐使用 event.stopPropagation() 方法来阻止；</li></ol></blockquote><blockquote><ol start="6"><li>事件默认行为的阻止<br>DOM1 事件绑定中(属性 on… 的方式)可以通过 return false 来阻止，但是在 DOM2 的事件绑定中(addEventListener)中，只能通过 event.preventDefault() 方法来阻止。</li></ol></blockquote><p>其实还有很多……懒得写了~~   ㄟ(▔,▔)ㄏ </p><blockquote><p> <strong>JS 优化问题 </strong></p><ol><li>最小化 DOM 访问次数，尽可能在 JS 端执行；</li><li>如果需要多次访问某个 DOM 节点，请使用局部变量存储对它的引用；</li><li>小心处理 HTML 集合，因为它实时连系着底层的文档，把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中；</li><li>如果可能的话，使用速度更快的 API，比如 querySelectorAll 和 firstElementChild；</li><li>要留意重绘和重排，批量修改样式时，“离线”操作 DOM 树。使用缓存，并减少访问布局的次数；</li><li>使用事件委托来减少事件处理器的数量；</li><li>避免多次访问对象成员或函数中的全局变量，尽量将它们赋值给局部变量以缓存；</li><li>能用 CSS 解决的问题，尽量不用 JS 去解决；</li></ol></blockquote><hr><p>#####写一个通用的事件侦听器函数？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">markyun.Event = &#123; // 页面加载完成后 </span><br><span class="line">    readyEvent: function(fn) &#123;</span><br><span class="line">        if (fn == null) &#123;</span><br><span class="line">            fn = document;</span><br><span class="line">        &#125;</span><br><span class="line">        var oldonload = window.onload;</span><br><span class="line">        if (typeof window.onload != &apos;function&apos;) &#123;</span><br><span class="line">            window.onload = fn;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                oldonload();</span><br><span class="line">                fn();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 视能力分别使用dom0||dom2||IE方式 来绑定事件 </span><br><span class="line">    // 参数： 操作的元素,事件名称 ,事件处理程序 </span><br><span class="line">    addEvent: function(element, type, handler) &#123;</span><br><span class="line">        if (element.addEventListener) &#123;</span><br><span class="line">            //事件类型、需要执行的函数、是否捕捉 </span><br><span class="line">            element.addEventListener(type, handler, false);</span><br><span class="line">        &#125; else if (element.attachEvent) &#123;</span><br><span class="line">            element.attachEvent(&apos;on&apos; + type, function() &#123;</span><br><span class="line">                handler.call(element);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            element[&apos;on&apos; + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 移除事件 </span><br><span class="line">    removeEvent: function(element, type, handler) &#123;</span><br><span class="line">        if (element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, false);</span><br><span class="line">        &#125; else if (element.datachEvent) &#123;</span><br><span class="line">            element.detachEvent(&apos;on&apos; + type, handler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            element[&apos;on&apos; + type] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) </span><br><span class="line">    stopPropagation: function(ev) &#123;</span><br><span class="line">        if (ev.stopPropagation) &#123;</span><br><span class="line">            ev.stopPropagation();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ev.cancelBubble = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 取消事件的默认行为 </span><br><span class="line">    preventDefault: function(event) &#123;</span><br><span class="line">        if (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.returnValue = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取事件目标 </span><br><span class="line">    getTarget: function(event) &#123;</span><br><span class="line">        return event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； </span><br><span class="line">    getEvent: function(e) &#123;</span><br><span class="line">        var ev = e || window.event;</span><br><span class="line">        if (!ev) &#123;</span><br><span class="line">            var c = this.getEvent.caller;</span><br><span class="line">            while (c) &#123;</span><br><span class="line">                ev = c.arguments[0];</span><br><span class="line">                if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125;</span><br><span class="line">                c = c.caller;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><hr><h5 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h5><blockquote><ul><li>它的功能是把对应的字符串解析成JS代码并运行；</li><li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 </li><li>由JSON字符串转换为JSON对象的时候可以用eval，例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj =eval(&apos;(&apos;+ str +&apos;)&apos;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><hr><h5 id="谈谈This对象的理解。"><a href="#谈谈This对象的理解。" class="headerlink" title="谈谈This对象的理解。"></a>谈谈This对象的理解。</h5><blockquote><ul><li>this总是指向函数的直接调用者（而非间接调用者）；</li><li>如果有new关键字，this指向new出来的那个对象；</li><li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；</li></ul></blockquote><hr><h5 id="javascript创建对象的几种方式？"><a href="#javascript创建对象的几种方式？" class="headerlink" title="javascript创建对象的几种方式？"></a>javascript创建对象的几种方式？</h5><blockquote><p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</p><ol><li><strong>对象字面量的方式</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person=&#123;firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol start="2"><li><p><strong>用function来模拟无参的构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(); <span class="comment">//定义一个function，如果使用new"实例化",该function可以看作是一个Class person.name="Mark";</span></span><br><span class="line">person.age = <span class="string">"25"</span>;</span><br><span class="line">person.work = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">      alert(person.name + <span class="string">" hello..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">person.work();</span><br></pre></td></tr></table></figure></li><li><p><strong>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）  </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Pet(name, age, hobby) &#123;</span><br><span class="line">    this.name = name; //this作用域：当前对象</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.hobby = hobby;</span><br><span class="line">    this.eat = function() &#123;</span><br><span class="line">        alert(&quot;我叫&quot; + this.name + &quot;,我喜欢&quot; + this.hobby + &quot;,是个程序员&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var maidou = new Pet(&quot;麦兜&quot;, 25, &quot;coding&quot;); //实例化、创建对象 maidou.eat();//调用eat方法</span><br></pre></td></tr></table></figure></li><li><p><strong> 用工厂方式来创建（内置对象） </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var wcDog =new Object(); </span><br><span class="line">wcDog.name=&quot;旺财&quot;; </span><br><span class="line">wcDog.age=3; </span><br><span class="line">wcDog.work=function()&#123;</span><br><span class="line">      alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);</span><br><span class="line"> &#125; </span><br><span class="line">wcDog.work();</span><br></pre></td></tr></table></figure></li><li><p><strong>用原型方式来创建 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Dog()&#123; &#125; </span><br><span class="line">Dog.prototype.name=&quot;旺财&quot;;</span><br><span class="line">Dog.prototype.eat=function()&#123;</span><br><span class="line">     alert(this.name+&quot;是个吃货&quot;);</span><br><span class="line"> &#125; </span><br><span class="line">var wangcai =new Dog(); </span><br><span class="line">wangcai.eat();</span><br></pre></td></tr></table></figure></li><li><p><strong>用混合方式来创建 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Car(name,price)&#123;</span><br><span class="line">    this.name=name;</span><br><span class="line">    this.price=price;</span><br><span class="line"> &#125; </span><br><span class="line">Car.prototype.sell=function()&#123;</span><br><span class="line">       alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);</span><br><span class="line"> &#125; </span><br><span class="line">var camry =new Car(&quot;凯美瑞&quot;,27); </span><br><span class="line">camry.sell();</span><br></pre></td></tr></table></figure></li></ol><hr><p>#####Javascript如何实现继承？</p><blockquote><ol><li>构造继承</li><li>原型继承</li><li>实例继承</li><li>拷贝继承</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。</span><br><span class="line">function Parent()&#123; </span><br><span class="line">  this.name = &apos;wang&apos;; </span><br><span class="line">&#125; </span><br><span class="line">function Child()&#123; </span><br><span class="line">  this.age = 28; </span><br><span class="line">&#125; </span><br><span class="line">Child.prototype = new Parent();//继承了Parent，通过原型 </span><br><span class="line">var demo = new Child(); </span><br><span class="line">alert(demo.age); </span><br><span class="line">alert(demo.name);//得到被继承的属性 &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>持续更新……………………</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;请描述一下-JavaScript-事件冒泡机制？&quot;&gt;&lt;a href=&quot;#请描述一下-JavaScript-事件冒泡机制？&quot; class=&quot;headerlink&quot; title=&quot;请描述一下 JavaScript 事件冒泡机制？&quot;&gt;&lt;/a&gt;请描述一下 JavaScri
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="https://kpeng.wang/tags/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题集锦（html篇）</title>
    <link href="https://kpeng.wang/2018/04/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6%EF%BC%88HTML%E7%AF%87%EF%BC%89/"/>
    <id>https://kpeng.wang/2018/04/25/前端面试题集锦（HTML篇）/</id>
    <published>2018-04-24T16:27:28.000Z</published>
    <updated>2018-04-25T16:33:47.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="请画出一个盒子模型图，并标出各项属性。"><a href="#请画出一个盒子模型图，并标出各项属性。" class="headerlink" title="请画出一个盒子模型图，并标出各项属性。"></a>请画出一个盒子模型图，并标出各项属性。</h5><p><img src="http://upload-images.jianshu.io/upload_images/3117374-a38a7eca62384ffb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="盒模型"></p><hr><h5 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h5><blockquote><p><strong>块级元素</strong>：<br>  <code>div，section，ul，dl，ol，li，dt，dd，p，h1-h6, nav……</code><br><strong>行内元素（又叫内联、内嵌元素）</strong>：<br>    <code>span, em, time, mark, strong, a……</code><br><strong>常见的空元素</strong>：<br>   <code>&lt;input&gt; &lt;link&gt; &lt;meta&gt;&lt;br&gt;&lt;wbr&gt; &lt;hr&gt;</code></p></blockquote><hr><h5 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h5><blockquote><ol><li>link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</li><li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li><li>import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</li></ol></blockquote><hr><h5 id="请分别列举-5-个-HTML5-新增的元素和-5-个-CSS3-新增属性"><a href="#请分别列举-5-个-HTML5-新增的元素和-5-个-CSS3-新增属性" class="headerlink" title="请分别列举 5 个 HTML5 新增的元素和 5 个 CSS3 新增属性?"></a>请分别列举 5 个 HTML5 新增的元素和 5 个 CSS3 新增属性?</h5><blockquote><p>HTML5 新增的元素：<br> section，nav，time，mark，header, footer…<br> CSS3 新增属性：<br> box-shadow， text-shadow，background-size，background-clip，mask， transform，filter…… </p></blockquote><hr><h5 id="data-属性的作用是什么？"><a href="#data-属性的作用是什么？" class="headerlink" title="data-属性的作用是什么？"></a>data-属性的作用是什么？</h5><blockquote><ol><li>data 自定义属性，本质就是给元素添加了个自定义属性，本来没有什么特殊的，只是一个官方化的自定义属性的添加方式， 在 js 中可以通过 dataset 统一管理；</li><li>通常的作用，一般我们会在 data 中存储一些和当前元素关联度比较大的数据； </li><li>一般也会用来做元素关联，比如给元素加索引。</li></ol></blockquote><hr><h5 id="H5哪些新API？"><a href="#H5哪些新API？" class="headerlink" title="H5哪些新API？"></a>H5哪些新API？</h5><blockquote><p>画布，视频，本地储存，离线储存，音频，拖放，表单，地理定位，套接字，web工作线程。</p></blockquote><hr><h5 id="H5为什么只需要写-lt-doctype-html-gt-？"><a href="#H5为什么只需要写-lt-doctype-html-gt-？" class="headerlink" title="H5为什么只需要写&lt;!doctype html &gt;？"></a>H5为什么只需要写&lt;!doctype html &gt;？</h5><blockquote><ul><li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</li><li>HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</li></ul></blockquote><hr><h5 id="Doctype作用？标准模式与兼容模式各有什么区别"><a href="#Doctype作用？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype作用？标准模式与兼容模式各有什么区别?"></a>Doctype作用？标准模式与兼容模式各有什么区别?</h5><blockquote><ul><li>&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</html></li><li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。</li></ul></blockquote><hr><h5 id="什么是H5的语义化？"><a href="#什么是H5的语义化？" class="headerlink" title="什么是H5的语义化？"></a>什么是H5的语义化？</h5><blockquote><p>使用正确的标签做正确的事情，便于团队开发和维护，结构清晰，利于SEO，加深权重特征。</p></blockquote><hr><p>#####HTML5的离线储存怎么使用，工作原理能不能解释一下？</p><blockquote><p>首先来讲解下离线存储的使用方法，说起来也很简单。只要在你的页面头部像下面一样加入一个<code>manifest</code>的属性就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html manifest = &quot;cache.manifest&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//cache.manifest`文件</span><br><span class="line">CACHE MANIFEST</span><br><span class="line">#v0.11</span><br><span class="line"></span><br><span class="line">CACHE:</span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">resourse/logo.png</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/ /offline.html</span><br></pre></td></tr></table></figure><blockquote><p>离线存储的manifest一般由三个部分组成:</p><ol><li><strong>CACHE</strong>:表示需要离线存储的资源列表，由于包含manifest文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li><strong>NETWORK</strong>:表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在CACHE和NETWORK中有一个相同的资源，那么这个资源还是会被离线存储，也就是说CACHE的优先级更高。</li><li><strong>FALLBACK</strong>:表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问offline.html。</li></ol></blockquote><blockquote><p><strong>localStorage </strong>   长期存储数据，浏览器关闭后数据不丢失；<br><strong>sessionStorage</strong>  数据在浏览器关闭后自动删除。<br>离线存储局势将一些源代码文件保存在本地，这样后续的页面重新加载将使用本地资源文件，在离线情况下可以继续访问web应用，同时通过一定的手法(更新相关文件或者使用相关 API)，可以更新、删除离线存储等操作。<br>利用本地存储的特性将重要和重复的数据保存在本地，避免页面的重复刷新，减少重要信息在传输过程中被泄露，增量传输修改内容。</p></blockquote><hr><h5 id="Label的作用是什么？是怎么用的？"><a href="#Label的作用是什么？是怎么用的？" class="headerlink" title="Label的作用是什么？是怎么用的？"></a>Label的作用是什么？是怎么用的？</h5><blockquote><p> label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p></blockquote><hr><h5 id="HTML5的form如何关闭自动完成功能？"><a href="#HTML5的form如何关闭自动完成功能？" class="headerlink" title="HTML5的form如何关闭自动完成功能？"></a>HTML5的form如何关闭自动完成功能？</h5><blockquote><p> 给不想要提示的 form 或某个 input 设置为 <code>autocomplete=off</code>。</p></blockquote><hr><h5 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h5><blockquote><p><strong>WebSocket</strong>、<strong>SharedWorker</strong>；<br>也可以调用<strong>localstorge</strong>、<strong>cookies</strong>等本地存储方式；</p><ul><li>localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；</li><li>注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</li></ul></blockquote><hr><h5 id="低版本兼容H5新标签？"><a href="#低版本兼容H5新标签？" class="headerlink" title="低版本兼容H5新标签？"></a>低版本兼容H5新标签？</h5><blockquote><p><code>html5shim.js</code>框架，用的是document.creatElement创建标签方法</p></blockquote><hr><h5 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h5><blockquote><p>一个是<strong>物理元素</strong>:<code>title, b, i</code><br>一个是<strong>逻辑元素</strong>: <code>h1,strong,em</code></p><ul><li><code>title</code>属性没有明确意义只表示是个标题，<code>H1</code>则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li><li><code>strong</code>是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<code>&lt;strong&gt;会重读</code>，而<code>&lt;B&gt;</code>是展示强调内容。</li><li><code>i</code>内容展示为斜体，<code>em</code>表示强调的文本；</li><li>Physical Style Elements – 自然样式标签<br><code>b, i, u, s, pre</code></li><li>Semantic Style Elements – 语义样式标签<br><code>strong, em, ins, del, code</code><br>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</li></ul></blockquote><hr><h5 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h5><blockquote><ul><li>iframe会阻塞主页面的Onload事件；</li><li>搜索引擎的检索程序无法解读这种页面，不利于SEO;</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li></ul></blockquote><p><strong>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</strong></p><hr><p><strong>持续更新……………………</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;请画出一个盒子模型图，并标出各项属性。&quot;&gt;&lt;a href=&quot;#请画出一个盒子模型图，并标出各项属性。&quot; class=&quot;headerlink&quot; title=&quot;请画出一个盒子模型图，并标出各项属性。&quot;&gt;&lt;/a&gt;请画出一个盒子模型图，并标出各项属性。&lt;/h5&gt;&lt;p&gt;&lt;i
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="https://kpeng.wang/tags/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>配一个趁手的gulp-cli环境</title>
    <link href="https://kpeng.wang/2018/04/25/%E9%85%8D%E4%B8%80%E4%B8%AA%E8%B6%81%E6%89%8B%E7%9A%84gulp-cli%E7%8E%AF%E5%A2%83/"/>
    <id>https://kpeng.wang/2018/04/25/配一个趁手的gulp-cli环境/</id>
    <published>2018-04-24T16:11:08.000Z</published>
    <updated>2018-04-24T16:15:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在之前分布尝试过不同的第三方编译工具，比如<a href="https://weflow.io/" target="_blank" rel="noopener">weflow</a>,<a href="https://legoflow.com/" target="_blank" rel="noopener">legoflow</a>等等之后，仍感觉抛出的配置参数功能不够顺手，它们底层其实也是用gulp.js配合少量其它的打包工具来封装实现的，主要方法是将config用模块化的方式来，逐个读取所需的stream实现。</p><p>公司之前的不少PC端项目都是使用的gulp.js，好处是上手快，配置轻巧，并且可以集成其它的打包工具来填平短板。所以打算整理一下。</p><p>主要是根据node环境来抽离出开发阶段与打包阶段的stream，尽量的加快编译速度以及打包速度。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://p.qlogo.cn/qqmail_head/tNn4SGP0ryVIicCBlQwszz1MK4ibMnMgDQy8cCzmVntSES9q7YJ8ac2hJw4Vp1HMl93ImYauPDRTI/0" alt="目录结构"></p><p>主要分为三个目录文件夹</p><ul><li><code>src</code> 开发环境资源文件</li><li><code>node_modules</code> 依赖包</li><li><code>dist</code> 生产环境(编译后文件)</li></ul><p>以及一些其它的配置文件</p><ul><li><code>.babelrc</code> babel的规则配置文件</li><li><code>.eslintignore</code>eslint忽略的规则配置文件</li><li><code>.eslintrc</code> eslint执行的规则配置文件 </li><li><code>gulpfile.js</code> gulp的stream配置文件</li><li><code>typings.json</code> typings的配置文件</li></ul><p><img src="https://p.qlogo.cn/qqmail_head/g0P5PPXZdbjc1uFQD5ic4uEgIY6FsZGr1uGcUHaYyNaDr8KicyJ44VOE6BraPIeBtD/0" alt="src目录说明"></p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p> <code>npm run dev</code></p><ol><li><strong>Sass语法编译</strong>(对应的sourcemap映射以及autoprefixer抹平兼容性前缀)</li><li><strong>Babel</strong> (对应的sourcemap映射)</li><li><strong>sprite雪碧图</strong>（自动生成相应的背景图片定位scss文件）</li><li><strong>includefile</strong></li><li><strong>集成typings </strong>(jquery,lodash语法提示)</li><li><strong>集成art-template</strong></li><li><strong>集成Rollup</strong>（主要使用tree-shaking摇树功能）</li><li><strong>集成eslint</strong></li><li><strong>middle-ware-server中间层代理</strong></li><li><strong>热更新</strong></li></ol><p>根据下图不难看出，目前的模块化形式为<code>umd</code>标准，即兼容amd与conmmonjs的写法，可以解决跨平台的解决方案。<br>最关键的是实现了tree-shaking, 即不会将整个import的js模块文件内容加入进来，而是仅将代码中使用到的方法导入<br><img src="https://p.qlogo.cn/qqmail_head/Q3auHgzwzM6NZ3fLpAqBLovOO4mndJsCL7icnOibzBEcvdJbCHRqj0r2SYpde8wjbr1rnueGL6jJc/0" alt="dev阶段"></p><hr><h3 id="打包阶段"><a href="#打包阶段" class="headerlink" title="打包阶段"></a>打包阶段</h3><p> <code>npm run build</code></p><ol><li>压缩html,js,css以及图片静态资源</li><li>添加md5</li></ol><p><img src="https://p.qlogo.cn/qqmail_head/ajNVdqHZLLBz98Fd73icsa0Oh6QggWJgJePofyJVjcibqSibeicNtBddNrEWlOt7Friaem3ZicNV08AibQ/0" alt="压缩"></p><h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><h4 id="typings实现智能"><a href="#typings实现智能" class="headerlink" title="typings实现智能"></a>typings实现智能</h4><p>这一点主要是针对编辑器，<a href="http://www.cnblogs.com/Leo_wl/p/5455619.html" target="_blank" rel="noopener">Typings实现智能</a></p><p><img src="https://p.qlogo.cn/qqmail_head/tNn4SGP0ryVIicCBlQwszz1MK4ibMnMgDQy8cCzmVntSEcOVbjp89LI3fNib4xW2T5zd91OE869MMM/0" alt="typings"></p><h4 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h4><p>需要注意的是，使用es6+的语法开发需要引入<a href="https://cdn.bootcss.com/babel-polyfill/6.26.0/polyfill.min.js" target="_blank" rel="noopener">babel-polyfill</a>来抹平低级浏览器的兼容问题。</p><h4 id="浏览器份额与分辨率份额"><a href="#浏览器份额与分辨率份额" class="headerlink" title="浏览器份额与分辨率份额"></a>浏览器份额与分辨率份额</h4><p>兼容这个问题是绕不开的，相对来说既令很多数让头疼不已，但是从另一个角度来看，也是一个鉴别经验水平的的分水岭之一，但是绝对抹平所有所有问题有些不切实际，会成倍增加额外开发成本。所以可以参考主流浏览器以及分辨率这两个维度来做适当的hacking。<br><img src="https://p.qlogo.cn/qqmail_head/tNn4SGP0ryVIicCBlQwszz1MK4ibMnMgDQy8cCzmVntSGWam37e5MicrhXSC9HfFQTyfdaRR7YjcLc/0" alt="分辨率份额"><br><img src="https://p.qlogo.cn/qqmail_head/tNn4SGP0ryVIicCBlQwszz1MK4ibMnMgDQy8cCzmVntSET0rfXgALuBGM4F2VK67huo9EyicNkSGXk/0" alt="浏览器份额"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在之前分布尝试过不同的第三方编译工具，比如&lt;a href=&quot;https://weflow.io/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="gulp" scheme="https://kpeng.wang/tags/gulp/"/>
    
      <category term="work-flow" scheme="https://kpeng.wang/tags/work-flow/"/>
    
  </entry>
  
</feed>
